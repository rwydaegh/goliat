{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GOLIAT","text":"<p>GOLIAT is an automated Python framework for near-field and far-field dosimetric assessments using the Sim4Life simulation platform. It streamlines EMF exposure simulations for research and compliance.</p> <ul> <li> <p> Quick Start</p> <p>Get running in minutes with installation and your first simulation.</p> <p> Get Started</p> </li> <li> <p> User Guide</p> <p>Understand workflows for near-field and far-field studies.</p> <p> Read Guide</p> </li> <li> <p> Tutorials</p> <p>Hands-on examples from basic runs to advanced batching.</p> <p> View Tutorials</p> </li> <li> <p> Configuration</p> <p>Customize simulations with JSON configs.</p> <p> Configure</p> </li> <li> <p> API Reference</p> <p>Detailed docs for classes and functions.</p> <p> API Docs</p> </li> <li> <p> Architecture</p> <p>Overview of the system design.</p> <p> Architecture</p> </li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>GOLIAT automates dosimetric assessments for the GOLIAT project, calculating SAR in digital human phantoms from device or environmental EMF exposure. Key features:</p> <ul> <li>Modular scene building (phantoms, antennas, plane waves).</li> <li>Local or cloud execution (iSolve/oSPARC).</li> <li>Results extraction and analysis (SAR metrics, plots).</li> <li>GUI for progress tracking.</li> <li>Automatic disk space management for serial workflows.</li> </ul> <p>Start with the Quick Start to run your first simulation.</p>"},{"location":"#why-goliat","title":"Why GOLIAT?","text":"<ul> <li>Efficiency: Handles setup, runs, and analysis in one tool.</li> <li>Reproducible: Config-driven for consistent results.</li> <li>Scalable: Local parallel or cloud batching for large studies.</li> <li>Accessible: Plain-language docs for newcomers.</li> </ul> <p>For issues, see Troubleshooting. Contribute via Developer Guide.</p>"},{"location":"COLORING_RULES/","title":"Coloring Rules for Terminal Output","text":"<p>This document outlines the rules for colorizing terminal output using the <code>colorama</code> library. The goal is to improve readability and draw the user's attention to the most critical information. All colors are defined in the <code>COLOR_MAP</code> dictionary in <code>src/colors.py</code> to ensure consistency and ease of maintenance.</p>"},{"location":"COLORING_RULES/#how-to-use","title":"How to Use","text":"<p>To apply a color, use the <code>_log</code> method from the <code>LoggingMixin</code> and specify the <code>log_type</code>.</p> <pre><code># Example usage:\nself._log(\"This is a warning message.\", log_type='warning')\nself._log(\"File saved successfully.\", level='progress', log_type='success')\n</code></pre> <p>Important: When adding a <code>log_type</code>, do not change the existing <code>level</code> parameter (e.g., <code>level='progress'</code>). The <code>level</code> controls which log file the message goes to, while <code>log_type</code> only controls the terminal color.</p>"},{"location":"COLORING_RULES/#color-to-type-mapping","title":"Color-to-Type Mapping","text":"<p>This table defines the intended use for each <code>log_type</code> and its corresponding color.</p> <code>log_type</code> Color Description &amp; Use Cases Example <code>default</code> White Standard, neutral output. Used for messages that don't fit any other category. <code>Running full simulation setup...</code> <code>header</code> Bright Magenta For major section headers that announce the start of a significant phase of the study. <code>--- Starting Far-Field Study: My Study ---</code> <code>progress</code> Green High-level progress updates that indicate a specific, positive step forward in the process. <code>--- Processing Frequency 1/5: 700MHz ---</code> <code>success</code> Bright Green Indicates the successful completion of a major operation or the entire study. <code>--- Study Finished ---</code> or <code>All required packages are already installed.</code> <code>info</code> Cyan Important, non-critical information that provides context, such as file paths or key configuration settings. <code>Project path set to: D:\\...</code> or <code>Solver kernel set to: Acceleware</code> <code>highlight</code> Bright Yellow Used to draw attention to a specific value or result within a block of text, such as a key performance metric. <code>Final Balance: 99.87%</code> <code>warning</code> Yellow For non-critical issues or potential problems that the user should be aware of, but that don't stop the process. <code>WARNING: Could not extract power balance.</code> or <code>GetPower() not available, falling back to manual extraction.</code> <code>error</code> Red For recoverable errors or failures within a specific part of the process. The overall study may continue. <code>ERROR: An error occurred during placement 'by_cheek': ...</code> <code>fatal</code> Magenta For critical, non-recoverable errors that will terminate the study. <code>FATAL ERROR: Could not find simulation bounding box.</code> <code>verbose</code> Blue Detailed, low-level debugging information intended for the <code>verbose</code> log stream. Not typically for progress updates. <code>- Activating line profiler for subtask: setup_simulation</code> <p>By following these rules, we can create a more intuitive and effective user experience.</p>"},{"location":"api/","title":"API Reference","text":"<p>This reference details GOLIAT's core classes and functions. It is generated from source code and includes descriptions, parameters, and usage examples. For full source, see src/.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#config","title":"Config","text":"<p>Loads and manages JSON configs with inheritance.</p> <p>Constructor: - <code>Config(base_dir, config_filename=\"near_field_config.json\")</code></p> <p>Key Methods: - <code>get_setting(path, default=None)</code>: Retrieves nested settings (e.g., \"study_type\").   - Example:     <pre><code>config = Config(\".\")\nstudy_type = config.get_setting(\"study_type\")  # Returns \"near_field\"\n</code></pre></p> <ul> <li><code>get_antenna_config()</code>: Returns antenna settings dict.</li> <li> <p>Example:     <pre><code>antennas = config.get_antenna_config()\npifa_700 = antennas[\"700\"]  # Dict with model_type, materials\n</code></pre></p> </li> <li> <p><code>get_profiling_config(study_type)</code>: Loads timing estimates.</p> </li> <li>Example:     <pre><code>profiling = config.get_profiling_config(\"near_field\")\navg_setup = profiling[\"avg_setup_time\"]  # e.g., 135.19 s\n</code></pre></li> </ul>"},{"location":"api/#studies","title":"Studies","text":""},{"location":"api/#basestudy","title":"BaseStudy","text":"<p>Base class for study orchestration.</p> <p>Constructor: - <code>BaseStudy(study_type, config_filename, gui, profiler)</code></p> <p>Key Methods: - <code>run()</code>: Executes the study workflow (setup, run, extract).   - Example:     <pre><code>from src.studies.near_field_study import NearFieldStudy\nstudy = NearFieldStudy(\"near_field\", \"config.json\", gui=None, profiler=None)\nstudy.run()  # Runs full study\n</code></pre></p>"},{"location":"api/#nearfieldstudy","title":"NearFieldStudy","text":"<p>Manages near-field simulations.</p> <p>Constructor: - <code>NearFieldStudy(config_filename, gui)</code></p> <p>Key Methods: - <code>_run_study()</code>: Loops over phantoms/frequencies/placements, calls setup/run/extract.   - Inherits from BaseStudy; uses PlacementSetup for antenna positioning.</p>"},{"location":"api/#farfieldstudy","title":"FarFieldStudy","text":"<p>Manages far-field simulations.</p> <p>Constructor: - <code>FarFieldStudy(config_filename, gui)</code></p> <p>Key Methods: - <code>_run_study()</code>: Loops over phantoms/frequencies, creates plane wave sims for directions/polarizations.</p>"},{"location":"api/#setup-components","title":"Setup Components","text":""},{"location":"api/#phantomsetup","title":"PhantomSetup","text":"<p>Loads and validates phantom models.</p> <p>Constructor: - <code>PhantomSetup(config, phantom_name, verbose_logger, progress_logger)</code></p> <p>Key Methods: - <code>ensure_phantom_is_loaded()</code>: Downloads/imports phantom if missing.   - Example:     <pre><code>phantom_setup = PhantomSetup(config, \"thelonious\", logger, logger)\nphantom_setup.ensure_phantom_is_loaded()  # Loads voxel model\n</code></pre></p>"},{"location":"api/#placementsetup","title":"PlacementSetup","text":"<p>Positions antenna relative to phantom.</p> <p>Constructor: - <code>PlacementSetup(config, phantom_name, frequency_mhz, placement_name, antenna, verbose_logger, progress_logger, free_space)</code></p> <p>Key Methods: - <code>place_antenna()</code>: Applies position/orientation from config.   - Example:     <pre><code>placement = PlacementSetup(config, \"thelonious\", 700, \"by_cheek\", antenna, logger, logger, False)\nplacement.place_antenna()  # Positions at 8mm from cheek\n</code></pre></p>"},{"location":"api/#materialsetup","title":"MaterialSetup","text":"<p>Assigns materials to entities.</p> <p>Constructor: - <code>MaterialSetup(config, simulation, antenna, phantom_name, verbose_logger, progress_logger, free_space)</code></p> <p>Key Methods: - <code>assign_materials(antenna_components, phantom_only=False)</code>: Maps config materials to CAD/tissues.   - Example:     <pre><code>material_setup = MaterialSetup(config, sim, antenna, \"thelonious\", logger, logger, False)\nmaterial_setup.assign_materials(components)  # Copper to antenna parts\n</code></pre></p>"},{"location":"api/#griddingsetup","title":"GriddingSetup","text":"<p>Configures spatial grid.</p> <p>Constructor: - <code>GriddingSetup(config, simulation, placement_name, antenna, verbose_logger, progress_logger, frequency_mhz)</code></p> <p>Key Methods: - <code>setup_gridding(antenna_components)</code>: Sets main grid and subgrids.   - Example:     <pre><code>gridding = GriddingSetup(config, sim, \"by_cheek\", antenna, logger, logger, 700)\ngridding.setup_gridding(components)  # Applies 3mm step\n</code></pre></p>"},{"location":"api/#sourcesetup","title":"SourceSetup","text":"<p>Configures EMF sources and sensors.</p> <p>Constructor: - <code>SourceSetup(config, simulation, frequency_mhz, antenna, verbose_logger, progress_logger, free_space)</code></p> <p>Key Methods: - <code>setup_source_and_sensors(antenna_components)</code>: Adds excitation (harmonic/Gaussian).   - Example:     <pre><code>source = SourceSetup(config, sim, 700, antenna, logger, logger, False)\nsource.setup_source_and_sensors(components)  # Sets port excitation\n</code></pre></p>"},{"location":"api/#core-components","title":"Core Components","text":""},{"location":"api/#projectmanager","title":"ProjectManager","text":"<p>Handles .smash project files.</p> <p>Constructor: - <code>ProjectManager(config, verbose_logger, progress_logger, gui=None)</code></p> <p>Key Methods: - <code>create_or_open_project(phantom_name, frequency_mhz, placement_name)</code>: Creates/opens .smash.   - Example:     <pre><code>pm = ProjectManager(config, logger, logger)\npm.create_or_open_project(\"thelonious\", 700, \"by_cheek\")  # Sets path, opens\n</code></pre></p>"},{"location":"api/#simulationrunner","title":"SimulationRunner","text":"<p>Executes simulations.</p> <p>Constructor: - <code>SimulationRunner(config, project_path, simulations, verbose_logger, progress_logger, gui, study)</code></p> <p>Key Methods: - <code>run_all()</code>: Runs list of simulations.   - Example:     <pre><code>runner = SimulationRunner(config, path, sims, logger, logger, gui, study)\nrunner.run_all()  # Executes iSolve or oSPARC\n</code></pre></p>"},{"location":"api/#resultsextractor","title":"ResultsExtractor","text":"<p>Post-processes simulation outputs.</p> <p>Constructor: - <code>ResultsExtractor(config, simulation, phantom_name, frequency_mhz, placement_name, study_type, verbose_logger, progress_logger, free_space, gui, study)</code></p> <p>Key Methods: - <code>extract()</code>: Pulls SAR/power balance.   - Example:     <pre><code>extractor = ResultsExtractor(config, sim, \"thelonious\", 700, \"by_cheek\", \"near_field\", logger, logger, False, gui, study)\nextractor.extract()  # Saves JSON/PKL with SAR values\n</code></pre></p>"},{"location":"api/#analysis","title":"Analysis","text":""},{"location":"api/#analyzer","title":"Analyzer","text":"<p>Orchestrates analysis with strategy.</p> <p>Constructor: - <code>Analyzer(config, phantom_name, strategy)</code></p> <p>Key Methods: - <code>run_analysis()</code>: Loads results, applies strategy, generates reports/plots.   - Example:     <pre><code>from src.analysis.strategies import NearFieldAnalysisStrategy\nstrategy = NearFieldAnalysisStrategy(config, \"thelonious\")\nanalyzer = Analyzer(config, \"thelonious\", strategy)\nanalyzer.run_analysis()  # Aggregates CSVs, plots\n</code></pre></p>"},{"location":"api/#plotter","title":"Plotter","text":"<p>Generates visualizations.</p> <p>Constructor: - <code>Plotter(plots_dir)</code></p> <p>Key Methods: - <code>plot_sar_heatmap(organ_df, group_df, tissue_groups)</code>: Heatmap of SAR by tissue/freq.   - Example:     <pre><code>plotter = Plotter(\"plots/\")\nplotter.plot_sar_heatmap(df, group_df, groups)  # Saves PNG\n</code></pre></p> <p>For full API, browse src/.</p> <p>Last updated: {date}</p>"},{"location":"architecture_overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of the GOLIAT project's architecture.</p>"},{"location":"architecture_overview/#workflow","title":"Workflow","text":"<p>The application follows a clear, modular workflow from configuration to results. The core logic is orchestrated by Study classes, which manage the entire simulation lifecycle.</p> <pre><code>graph TD\n    A[Start] --&gt; B{Load Config}\n    B --&gt; C{Select Study Type}\n    C --&gt; D[Near-Field Study]\n    C --&gt; E[Far-Field Study]\n    D --&gt; F{Run Simulation}\n    E --&gt; F\n    F --&gt; G[Extract Results]\n    G --&gt; H[End]\n\n    style A fill:#4CAF50\n    style H fill:#4CAF50\n    style D fill:#2196F3\n    style E fill:#2196F3\n    style F fill:#FF9800\n    style G fill:#9C27B0\n</code></pre>"},{"location":"architecture_overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"User Interface Layer\"\n        GUI[GUI Manager&lt;br/&gt;PySide6]\n        CLI[Command Line]\n    end\n\n    subgraph \"Orchestration Layer\"\n        Study[Study Classes&lt;br/&gt;NearFieldStudy / FarFieldStudy]\n        Config[Configuration Manager]\n        Profiler[Profiler &amp; Progress Tracking]\n    end\n\n    subgraph \"Core Processing Layer\"\n        PM[Project Manager]\n        Setup[Setup Classes&lt;br/&gt;Scene Building]\n        Runner[Simulation Runner]\n        Extractor[Results Extractor]\n    end\n\n    subgraph \"External Services\"\n        S4L[Sim4Life Engine]\n        oSPARC[oSPARC Cloud]\n    end\n\n    GUI --&gt; Study\n    CLI --&gt; Study\n    Study --&gt; Config\n    Study --&gt; Profiler\n    Study --&gt; PM\n    Study --&gt; Setup\n    Study --&gt; Runner\n    Study --&gt; Extractor\n    Runner --&gt; S4L\n    Runner --&gt; oSPARC\n    Setup --&gt; S4L\n    Extractor --&gt; S4L\n\n    style GUI fill:#E1BEE7\n    style Study fill:#BBDEFB\n    style Setup fill:#C5E1A5\n    style Runner fill:#FFE082\n    style Extractor fill:#FFCCBC\n</code></pre>"},{"location":"architecture_overview/#component-interactions","title":"Component Interactions","text":"<pre><code>sequenceDiagram\n    participant User\n    participant GUI\n    participant Study\n    participant Setup\n    participant Runner\n    participant Extractor\n    participant Files\n\n    User-&gt;&gt;GUI: Start Study\n    GUI-&gt;&gt;Study: Initialize\n    Study-&gt;&gt;Setup: Configure Scene\n    Setup-&gt;&gt;Files: Create .smash\n    Study-&gt;&gt;Runner: Execute Simulation\n    Runner-&gt;&gt;Files: Generate Input (.h5)\n    Runner-&gt;&gt;Runner: Run Solver\n    Runner-&gt;&gt;Files: Write Results\n    Study-&gt;&gt;Extractor: Process Results\n    Extractor-&gt;&gt;Files: Read Output\n    Extractor-&gt;&gt;Files: Save Reports\n    Study-&gt;&gt;GUI: Update Progress\n    GUI-&gt;&gt;User: Show Completion\n</code></pre>"},{"location":"architecture_overview/#key-components","title":"Key Components","text":""},{"location":"architecture_overview/#entry-points","title":"Entry Points","text":"<code>run_study.py</code>: The main entry point. Launches GUI and study process. <code>run_study_no_gui.py</code>: Headless CLI for batch/automation."},{"location":"architecture_overview/#core-classes","title":"Core Classes","text":"<code>Config</code>: Loads JSON configs with inheritance. <code>NearFieldStudy</code> / <code>FarFieldStudy</code>: Orchestrate workflow: Loop over parameters, call setups/runner/extractor. <code>ProjectManager</code>: Manages .smash files (create/open/save/close, lock handling)."},{"location":"architecture_overview/#setup-components","title":"Setup Components","text":"<code>NearFieldSetup</code> / <code>FarFieldSetup</code>: Build scene: Phantoms, antennas/sources, materials, gridding, boundaries. <code>PhantomSetup</code>: Loads voxel models. <code>PlacementSetup</code>: Positions antennas. <code>MaterialSetup</code>: Assigns tissue/material properties. <code>GriddingSetup</code>: Sets grid resolution. <code>BoundarySetup</code>: Configures PML boundaries. <code>SourceSetup</code>: Adds excitations/sensors."},{"location":"architecture_overview/#execution-components","title":"Execution Components","text":"<code>SimulationRunner</code>: Runs iSolve (local) or submits to oSPARC. <code>ResultsExtractor</code>: Extracts SAR, power balance, point sensors."},{"location":"architecture_overview/#analysis-components","title":"Analysis Components","text":"<code>Analyzer</code>: Aggregates results using strategies (near/far-field). <code>Plotter</code>: Generates heatmaps, bars, boxplots."},{"location":"architecture_overview/#ui-components","title":"UI Components","text":"<code>GuiManager</code>: Progress window with multiprocessing queue. <code>Profiler</code>: Estimates ETA based on phase weights."},{"location":"architecture_overview/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<pre><code>graph TD\n    base[base_config.json&lt;br/&gt;Common Settings]\n    nf[near_field_config.json&lt;br/&gt;Overrides &amp; Specifics]\n    ff[far_field_config.json&lt;br/&gt;Overrides &amp; Specifics]\n\n    base --&gt; nf\n    base --&gt; ff\n\n    style base fill:#4CAF50\n    style nf fill:#2196F3\n    style ff fill:#2196F3\n</code></pre> <p>For detailed information, refer to the API Reference.</p>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>GOLIAT uses a hierarchical JSON configuration system to define simulation parameters. Study-specific configs (e.g., <code>near_field_config.json</code>) inherit from <code>base_config.json</code>, allowing overrides for specific studies. This guide details all parameters, with examples.</p>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The system supports inheritance to avoid repetition:</p> <pre><code>graph TD\n    base[base_config.json&lt;br/&gt;Common settings]\n    nf[near_field_config.json&lt;br/&gt;Near-field specifics]\n    ff[far_field_config.json&lt;br/&gt;Far-field specifics]\n\n    base --&gt;|extends| nf\n    base --&gt;|extends| ff\n\n    style base fill:#4CAF50\n    style nf fill:#2196F3\n    style ff fill:#2196F3\n</code></pre> <p>A study config specifies <code>\"extends\": \"base_config.json\"</code> and overrides as needed.</p>"},{"location":"configuration/#base-configuration-base_configjson","title":"Base Configuration (<code>base_config.json</code>)","text":"<p>Core settings shared across studies.</p>"},{"location":"configuration/#core-settings","title":"Core Settings","text":"Parameter Type Example Description <code>extends</code> string <code>\"base_config.json\"</code> Parent config to inherit from. <code>study_type</code> string <code>\"near_field\"</code> Type: <code>\"near_field\"</code> or <code>\"far_field\"</code>. <code>phantoms</code> array <code>[\"thelonious\", \"eartha\"]</code> List of phantom models. For near-field, can include <code>\"freespace\"</code> for antenna-only runs. <code>execution_control</code> object See below Controls workflow stages."},{"location":"configuration/#execution-control","title":"Execution Control","text":"<p>Booleans to run specific phases:</p> Parameter Type Default Description <code>execution_control.do_setup</code> boolean <code>true</code> Build simulation scene. <code>execution_control.do_run</code> boolean <code>true</code> Execute simulations. <code>execution_control.do_extract</code> boolean <code>true</code> Extract and normalize results. <code>execution_control.only_write_input_file</code> boolean <code>false</code> Generate .h5 inputs without running (for manual/cloud upload). <code>execution_control.batch_run</code> boolean <code>false</code> Enable oSPARC batch submission (advanced). <code>execution_control.auto_cleanup_previous_results</code> array <code>[]</code> List of file types to automatically delete before each simulation. Valid values: <code>\"output\"</code> (<code>*_Output.h5</code>), <code>\"input\"</code> (<code>*_Input.h5</code>), <code>\"smash\"</code> (<code>*.smash</code>). Warning: Only use in serial workflows with all phases enabled; incompatible with parallel/batch runs. <p>Example for extraction only:</p> <pre><code>\"execution_control\": {\n  \"do_setup\": false,\n  \"do_run\": false,\n  \"do_extract\": true\n}\n</code></pre> <p>Example with auto-cleanup for serial workflow:</p> <pre><code>\"execution_control\": {\n  \"do_setup\": true,\n  \"do_run\": true,\n  \"do_extract\": true,\n  \"auto_cleanup_previous_results\": [\"output\"]\n}\n</code></pre> <p>Example with aggressive cleanup (output + input files):</p> <pre><code>\"execution_control\": {\n  \"do_setup\": true,\n  \"do_run\": true,\n  \"do_extract\": true,\n  \"auto_cleanup_previous_results\": [\"output\", \"input\"]\n}\n</code></pre> <p>Example with full cleanup (all files including .smash projects):</p> <pre><code>\"execution_control\": {\n  \"do_setup\": true,\n  \"do_run\": true,\n  \"do_extract\": true,\n  \"auto_cleanup_previous_results\": [\"output\", \"input\", \"smash\"]\n}\n</code></pre> <p>Important Notes on <code>auto_cleanup_previous_results</code>:</p> <ul> <li>Purpose: Selectively deletes a simulation's files after its results have been successfully extracted to preserve disk space.</li> <li>File Types:</li> <li><code>\"output\"</code>: Simulation results (<code>*_Output.h5</code>) - safe to delete after extraction is complete</li> <li><code>\"input\"</code>: Solver input files (<code>*_Input.h5</code>) - can be regenerated during setup</li> <li><code>\"smash\"</code>: Project files (<code>*.smash</code>) - use with extreme caution, deletes entire project</li> <li>Safe Usage: Only enable when running complete serial workflows where <code>do_setup</code>, <code>do_run</code>, and <code>do_extract</code> are all <code>true</code>.</li> <li>Warnings:</li> <li>Do NOT use with <code>batch_run: true</code> or parallel execution - this will cause data corruption!</li> <li>Do NOT use when running phases separately (e.g., only setup and run) - the cleanup will not be triggered.</li> <li>Be very careful with <code>\"smash\"</code> option - it deletes the entire project file</li> <li>If misused, GOLIAT will automatically disable this feature and log warnings.</li> <li>Backward Compatibility: Legacy boolean format (<code>true</code>/<code>false</code>) is supported and automatically converts to <code>[\"output\"]</code> or <code>[]</code>.</li> </ul>"},{"location":"configuration/#simulation-parameters","title":"Simulation Parameters","text":"<p>General simulation settings.</p> Parameter Type Example Description <code>simulation_parameters.excitation_type</code> string <code>\"Harmonic\"</code> Excitation: <code>\"Harmonic\"</code> (single frequency) or <code>\"Gaussian\"</code> (sweep; for antenna characterization). <code>simulation_parameters.bandwidth_mhz</code> number <code>50.0</code> Bandwidth for Gaussian (MHz). <code>simulation_parameters.global_auto_termination</code> string <code>\"GlobalAutoTerminationUserDefined\"</code> Termination: <code>\"GlobalAutoTerminationWeak\"</code> (default) or <code>\"GlobalAutoTerminationUserDefined\"</code> (custom dB). <code>simulation_parameters.convergence_level_dB</code> number <code>-15</code> Convergence threshold (dB) for user-defined termination. <code>simulation_parameters.simulation_time_multiplier</code> number <code>5</code> Multiplier for time calculation: diagonal length / c * multiplier. <code>simulation_parameters.number_of_point_sensors</code> number <code>8</code> Point sensors at bounding box corners for field monitoring. <code>simulation_parameters.point_source_order</code> array <code>[\"lower_left_bottom\", ...]</code> Order of 8 corner points for sensors. <code>simulation_parameters.bbox_padding_mm</code> number <code>50</code> Padding around phantom for simulation domain (far-field). <code>simulation_parameters.freespace_antenna_bbox_expansion_mm</code> array <code>[20, 20, 20]</code> Padding for free-space antenna runs [x, y, z] mm."},{"location":"configuration/#gridding-parameters","title":"Gridding Parameters","text":"<p>Spatial discretization.</p>"},{"location":"configuration/#global-gridding","title":"Global Gridding","text":"Parameter Type Example Description <code>gridding_parameters.global_gridding.grid_mode</code> string <code>\"automatic\"</code> <code>\"automatic\"</code> (default) or <code>\"manual\"</code>. <code>gridding_parameters.global_gridding.refinement</code> string <code>\"AutoRefinementDefault\"</code> Auto levels: <code>\"VeryFine\"</code>, <code>\"Fine\"</code>, <code>\"Default\"</code>, <code>\"Coarse\"</code>, <code>\"VeryCoarse\"</code>. <code>gridding_parameters.global_gridding.manual_fallback_max_step_mm</code> number <code>5.0</code> Max grid step mm (manual mode). <code>gridding_parameters.global_gridding_per_frequency</code> object <code>{\"700\": 3.0}</code> Frequency-specific manual steps (e.g., finer at higher freqs)."},{"location":"configuration/#padding","title":"Padding","text":"Parameter Type Example Description <code>gridding_parameters.padding.padding_mode</code> string <code>\"automatic\"</code> <code>\"automatic\"</code> or <code>\"manual\"</code>. <code>gridding_parameters.padding.manual_bottom_padding_mm</code> array <code>[0, 0, 0]</code> Bottom padding [x, y, z] mm. <code>gridding_parameters.padding.manual_top_padding_mm</code> array <code>[0, 0, 0]</code> Top padding [x, y, z] mm."},{"location":"configuration/#solver-settings","title":"Solver Settings","text":"Parameter Type Example Description <code>solver_settings.kernel</code> string <code>\"Acceleware\"</code> <code>\"Software\"</code> (CPU), <code>\"Acceleware\"</code> (GPU, default for near-field), <code>\"CUDA\"</code> (GPU, faster but no SIBC for near-field). <code>solver_settings.boundary_conditions.type</code> string <code>\"UpmlCpml\"</code> Boundary type. <code>solver_settings.boundary_conditions.strength</code> string <code>\"Medium\"</code> PML strength: <code>\"Weak\"</code>, <code>\"Medium\"</code>, <code>\"Strong\"</code>."},{"location":"configuration/#other-settings","title":"Other Settings","text":"Parameter Type Example Description <code>manual_isolve</code> boolean <code>true</code> Run iSolve.exe directly (recommended; avoids Ares bug). <code>download_email</code> string <code>\"user@example.com\"</code> Email for phantom downloads. <code>export_material_properties</code> boolean <code>false</code> Export material props to PKL (advanced)."},{"location":"configuration/#far-field-configuration-far_field_configjson","title":"Far-Field Configuration (<code>far_field_config.json</code>)","text":"<p>Extends base for far-field specifics.</p>"},{"location":"configuration/#study-setup","title":"Study Setup","text":"Parameter Type Example Description <code>frequencies_mhz</code> array <code>[450, 700]</code> Frequencies MHz. <code>far_field_setup.type</code> string <code>\"environmental\"</code> <code>\"environmental\"</code> (plane waves) or <code>\"auto_induced\"</code> (body-motion induced; limited). <code>far_field_setup.environmental.incident_directions</code> array <code>[\"x_pos\", \"y_neg\"]</code> Single-axis directions: <code>\"x_pos\"</code>, <code>\"x_neg\"</code>, <code>\"y_pos\"</code>, <code>\"y_neg\"</code>, <code>\"z_pos\"</code>, <code>\"z_neg\"</code>. <code>far_field_setup.environmental.polarizations</code> array <code>[\"theta\", \"phi\"]</code> Polarizations: <code>\"theta\"</code> (vertical), <code>\"phi\"</code> (horizontal). <p>Note: Only 6 directions supported (x\u00b1, y\u00b1, z\u00b1). For environmental, 12 simulations per freq (6 \u00d7 2).</p>"},{"location":"configuration/#example-far-field-config","title":"Example Far-Field Config","text":"<pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"far_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700],\n  \"far_field_setup\": {\n    \"type\": \"environmental\",\n    \"environmental\": {\n      \"incident_directions\": [\"x_pos\", \"y_pos\"],\n      \"polarizations\": [\"theta\"]\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/#near-field-configuration-near_field_configjson","title":"Near-Field Configuration (<code>near_field_config.json</code>)","text":"<p>Extends base for near-field.</p>"},{"location":"configuration/#study-setup_1","title":"Study Setup","text":"Parameter Type Example Description <code>frequencies_mhz</code> array <code>[700, 900]</code> Frequencies MHz. <code>simulation_parameters.freespace_antenna_bbox_expansion_mm</code> array <code>[20, 20, 20]</code> Free-space padding [x, y, z] mm."},{"location":"configuration/#antenna-configuration","title":"Antenna Configuration","text":"<p>Per-frequency settings:</p> <pre><code>\"antenna_config\": {\n  \"700\": {\n    \"model_type\": \"PIFA\",\n    \"source_name\": \"Lines 1\",\n    \"materials\": {\n      \"Extrude 1\": \"Copper (Annealed)\",\n      \"Extrude 2\": \"FR4 (Circuit Board)\"\n    },\n    \"gridding\": {\n      \"automatic\": [\"Extrude 2\"],\n      \"manual\": {\n        \"Extrude 1\": 0.5\n      }\n    }\n  }\n}\n</code></pre> <ul> <li><code>model_type</code>: <code>\"PIFA\"</code> or <code>\"IFA\"</code> (selects logic).</li> <li><code>source_name</code>: Source entity in CAD.</li> <li><code>materials</code>: CAD component to Sim4Life material.</li> <li><code>gridding</code>: Auto/manual per component.</li> </ul> <p>Note: Antenna configs fixed for GOLIAT; modify for custom models.</p>"},{"location":"configuration/#placement-scenarios","title":"Placement Scenarios","text":"<p>Define positions/orientations:</p> <pre><code>\"placement_scenarios\": {\n  \"by_cheek\": {\n    \"positions\": {\"base\": [0, 0, 0]},\n    \"orientations\": {\"base\": [], \"up\": [{\"axis\": \"X\", \"angle_deg\": 10}]}\n  }\n}\n</code></pre>"},{"location":"configuration/#phantom-specific-settings","title":"Phantom-Specific Settings","text":"<p>Per-phantom placements/distances:</p> <pre><code>\"phantom_definitions\": {\n  \"thelonious\": {\n    \"placements\": {\n      \"do_by_cheek\": true\n    },\n    \"distance_from_cheek\": 8\n  }\n}\n</code></pre>"},{"location":"configuration/#example-near-field-config","title":"Example Near-Field Config","text":"<pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700],\n  \"phantom_definitions\": {\n    \"thelonious\": {\n      \"placements\": {\n        \"do_by_cheek\": true\n      },\n      \"distance_from_cheek\": 8\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/#osparc-cloud-settings","title":"oSPARC Cloud Settings","text":"<p>Credentials in <code>.env</code> (not config for security).</p> <p>Batch workflow: 1. <code>\"only_write_input_file\": true</code> \u2013 Generate .h5 files. 2. <code>\"batch_run\": true</code> \u2013 Submit to oSPARC. 3. <code>\"do_extract\": true</code> \u2013 Process results.</p> <p>Example batch config:</p> <pre><code>\"execution_control\": {\n  \"do_setup\": true,\n  \"only_write_input_file\": true,\n  \"do_run\": false,\n  \"do_extract\": false,\n  \"batch_run\": false\n}\n</code></pre>"},{"location":"configuration/#line-profiling-advanced","title":"Line Profiling (Advanced)","text":"<p>Enable in config:</p> <pre><code>\"line_profiling\": {\n  \"enabled\": true,\n  \"subtasks\": {\n    \"setup_simulation\": [\"src.setups.base_setup.BaseSetup._finalize_setup\"]\n  }\n}\n</code></pre>"},{"location":"configuration/#example-custom-config","title":"Example Custom Config","text":"<p>Create <code>configs/my_study.json</code>:</p> <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"eartha\"],\n  \"frequencies_mhz\": [900, 1800],\n  \"phantom_definitions\": {\n    \"eartha\": {\n      \"placements\": {\n        \"do_front_of_eyes\": true\n      },\n      \"distance_from_eye\": 200\n    }\n  }\n}\n</code></pre> <p>Run: <code>python run_study.py --config configs/my_study.json</code>.</p> <p>For full details, see User Guide.</p>"},{"location":"developer_guide/","title":"Developer Guide","text":"<p>This guide is for developers extending or maintaining GOLIAT. It covers the codebase structure, testing, and contribution process. GOLIAT is modular Python code interfacing with Sim4Life for EMF simulations.</p>"},{"location":"developer_guide/#codebase-structure","title":"Codebase Structure","text":"<p>GOLIAT's architecture separates concerns:</p> <ul> <li>src/config.py: Loads JSON configs with inheritance (e.g., base + study-specific).</li> <li>src/studies/: Orchestrates workflows (NearFieldStudy, FarFieldStudy inherit from BaseStudy).</li> <li>src/setups/: Builds Sim4Life scenes (PhantomSetup, PlacementSetup, MaterialSetup, etc.).</li> <li>src/project_manager.py: Handles .smash files (create/open/save/close).</li> <li>src/simulation_runner.py: Executes simulations (local iSolve or oSPARC cloud).</li> <li>src/results_extractor.py: Extracts SAR/power data post-simulation.</li> <li>src/analysis/: Aggregates results (Analyzer with strategies for near/far-field).</li> <li>src/gui_manager.py: Multiprocessing GUI for progress/ETA.</li> <li>src/logging_manager.py: Dual loggers (progress/verbose) with colors.</li> <li>src/profiler.py: Tracks phases (setup/run/extract) for ETAs.</li> <li>src/utils.py: Helpers (format_time, non_blocking_sleep, simple Profiler).</li> </ul> <p>Key flow: Config \u2192 BaseStudy.run() \u2192 Setups \u2192 Runner \u2192 Extractor \u2192 Analyzer.</p>"},{"location":"developer_guide/#logging-and-colors","title":"Logging and Colors","text":"<p>GOLIAT uses two loggers: - progress: High-level updates (console, .progress.log). - verbose: Detailed info (console, .log).</p> <p>Colors via colorama in <code>src/colors.py</code> (e.g., warnings yellow, errors red). Defined in COLOR_MAP:</p> log_type Color Use Case default White Standard messages. header Bright Magenta Phase starts (e.g., \"Starting Setup\"). progress Green Progress updates (e.g., \"Processing Frequency \u2155\"). success Bright Green Completion (e.g., \"Study Finished\"). info Cyan Context (e.g., \"Project path set to...\"). highlight Bright Yellow Key values (e.g., \"Balance: 99.87%\"). warning Yellow Non-critical issues. error Red Recoverable errors. fatal Magenta Critical failures (stops study). verbose Blue Debug info. <p>Use <code>_log(message, level='progress', log_type='info')</code> in classes (via LoggingMixin).</p> <p>How to Use Logging:</p> <p>To apply a color, use the <code>_log</code> method from the <code>LoggingMixin</code> and specify the <code>log_type</code>.</p> <pre><code># Example usage:\nself._log(\"This is a warning message.\", log_type='warning')\nself._log(\"File saved successfully.\", level='progress', log_type='success')\n</code></pre> <p>Important: When adding a <code>log_type</code>, do not change the existing <code>level</code> parameter (e.g., <code>level='progress'</code>). The <code>level</code> controls which log file the message goes to, while <code>log_type</code> only controls the terminal color.</p>"},{"location":"developer_guide/#profiling","title":"Profiling","text":"<p>Two profilers: - src/profiler.py: Phase-based (setup/run/extract weights in profiling_config.json). Tracks ETAs.   - Methods: <code>start_stage()</code>, <code>end_stage()</code>, <code>get_time_remaining()</code>. - src/utils.py Profiler: Simple timing for subtasks (average_run_time in config).</p> <p>Enable line profiling in config:</p> <pre><code>\"line_profiling\": {\n  \"enabled\": true,\n  \"subtasks\": {\n    \"setup_simulation\": [\"src.setups.base_setup.BaseSetup._finalize_setup\"]\n  }\n}\n</code></pre> <p>Run with kernprof: <code>kernprof -l -v run_study.py</code>.</p> <p>Profiling and Timing Deep-Dive:</p> <p>The <code>Profiler</code> class is the engine for the timing and progress estimation system.</p> <ul> <li>Phases and Weights: A study is divided into phases (<code>setup</code>, <code>run</code>, <code>extract</code>). <code>profiling_config.json</code> assigns a \"weight\" to each, representing its contribution to the total time.   <pre><code>// from configs/profiling_config.json\n{\n    \"phase_weights\": {\n      \"setup\": 0.299,\n      \"run\": 0.596,\n      \"extract\": 0.105\n    },\n    \"subtask_estimates\": {\n      \"setup_simulation\": 48.16,\n      \"run_simulation_total\": 107.54,\n      \"extract_sar_statistics\": 4.09\n    }\n}\n</code></pre></li> <li>Dynamic Weights: The profiler normalizes these weights based on which phases are active (controlled by <code>execution_control</code> in the config). If a user chooses to only run the <code>extract</code> phase, its weight becomes 1.0, and the progress for that phase represents 100% of the total work.</li> <li>Weighted Progress: The <code>get_weighted_progress</code> method provides a more accurate overall progress.   <pre><code># from src/utils.py\ndef get_weighted_progress(self, phase_name, phase_progress):\n    \"\"\"Calculates the overall progress based on phase weights.\"\"\"\n    total_progress = 0\n    for phase, weight in self.phase_weights.items():\n        if phase == phase_name:\n            total_progress += weight * phase_progress # Add partial progress of current phase\n        elif phase in self.completed_phases:\n            total_progress += weight # Add full weight of completed phases\n    return total_progress * 100\n</code></pre></li> <li>Time Estimation (ETA): The <code>get_time_remaining</code> method is adaptive. Initially, it relies on the <code>subtask_estimates</code>. Once one or more stages have completed, it switches to a more accurate method based on the actual average time taken per stage.</li> <li>Self-Improving Estimates: After a run, <code>save_estimates</code> calculates the average time for each timed subtask and writes these new averages back to <code>profiling_config.json</code>. This makes future estimates more accurate.</li> </ul> <p>GUI and Multiprocessing Deep-Dive:</p> <p>The application is designed to run scientific studies (e.g., Near-Field, Far-Field) which can be time-consuming. To provide user feedback and manage complexity, the system employs a multi-process architecture.</p> <ol> <li>Main Process: A lightweight PySide6 GUI (<code>ProgressGUI</code>) is launched. This GUI is responsible for displaying progress, logs, and timing information.</li> <li>Study Process: The actual study (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>) is executed in a separate process using Python's <code>multiprocessing</code> module. This prevents the GUI from freezing during intensive calculations.</li> <li>Communication: The study process communicates with the GUI process through a <code>multiprocessing.Queue</code>. It sends messages containing status updates, progress information, and timing data.</li> </ol> <p>The entry point for the study process is the <code>study_process_wrapper</code> function, which sets up a special <code>QueueGUI</code> object. This object mimics the real GUI's interface but directs all its output to the shared queue.</p> <pre><code># from src/gui_manager.py\ndef study_process_wrapper(queue, study_type, config_filename, verbose, session_timestamp, execution_control):\n    \"\"\"\n    This function runs in a separate process and executes the study.\n    It communicates with the main GUI process via a queue.\n    \"\"\"\n    # ... setup ...\n    class QueueGUI:\n        def __init__(self, queue):\n            self.queue = queue\n            self.profiler = None\n\n        def log(self, message, level='verbose'):\n            if level == 'progress':\n                self.queue.put({'type': 'status', 'message': message})\n\n        def update_overall_progress(self, current_step, total_steps):\n            self.queue.put({'type': 'overall_progress', 'current': current_step, 'total': total_steps})\n        # ... other methods ...\n\n    if study_type == 'near_field':\n        study = NearFieldStudy(config_filename=config_filename, verbose=verbose, gui=QueueGUI(queue))\n    # ...\n    study.run()\n    queue.put({'type': 'finished'})\n</code></pre> <pre><code>graph TD\n    A[Main Process: ProgressGUI] -- Spawns --&gt; B[Study Process: study_process_wrapper];\n    B -- Instantiates --&gt; Study[NearFieldStudy/FarFieldStudy];\n    Study -- Uses --&gt; QueueGUI[QueueGUI object];\n    QueueGUI -- Puts messages --&gt; C{multiprocessing.Queue};\n    C -- Polled by QTimer --&gt; A;\n    A -- Updates UI --&gt; D[User];\n</code></pre> <p>Message Processing:</p> <p>The <code>ProgressGUI</code> uses a <code>QTimer</code> that fires every 100ms, calling the <code>process_queue</code> method. This method drains the queue of any pending messages from the study process and updates the UI accordingly.</p> <pre><code># from src/gui_manager.py\nclass ProgressGUI(QWidget):\n    # ...\n    def process_queue(self):\n        while not self.queue.empty():\n            try:\n                msg = self.queue.get_nowait()\n                msg_type = msg.get('type')\n\n                if msg_type == 'status':\n                    self.update_status(msg['message'])\n                elif msg_type == 'overall_progress':\n                    self.update_overall_progress(msg['current'], msg['total'])\n                elif msg_type == 'stage_progress':\n                    self.update_stage_progress(msg['name'], msg['current'], msg['total'])\n                elif msg_type == 'start_animation':\n                    self.start_stage_animation(msg['estimate'], msg['end_value'])\n                # ... other message types ...\n            except Empty:\n                break\n</code></pre> <p>The Animation System:</p> <p>A key feature for user experience is the smooth animation of the stage progress bar. This is used for tasks where the simulation software doesn't provide real-time progress feedback, but we have a historical estimate of how long it should take.</p> <p>How it works:</p> <ol> <li> <p>Initiation: The study process, before starting a long-running subtask (like <code>run_simulation_total</code>), gets an estimated duration from the <code>Profiler</code>. It then sends a <code>start_animation</code> message to the GUI, containing this estimated duration.     <pre><code># from src/studies/far_field_study.py (conceptual)\ndef run_simulations(self):\n    # ...\n    if self.gui:\n        # Tell the GUI to start an animation for the next step\n        self.gui.start_stage_animation(\"run_simulation_total\", i + 1)\n    self.simulation_runner.run(sim)\n</code></pre>     The <code>QueueGUI</code> object in the study process gets the estimate from its profiler instance and puts the message on the queue.     <pre><code># from src/gui_manager.py\nclass QueueGUI:\n    # ...\n    def start_stage_animation(self, task_name, end_value):\n        estimate = self.profiler.get_subtask_estimate(task_name)\n        self.queue.put({'type': 'start_animation', 'estimate': estimate, 'end_value': end_value})\n</code></pre></p> </li> <li> <p>Animation Setup: When the <code>ProgressGUI</code> receives the <code>start_animation</code> message, it sets up the animation parameters. It records the <code>start_time</code>, the <code>duration</code> (from the profiler's estimate), the progress bar's <code>start_value</code>, and the <code>end_value</code> it needs to reach.     <pre><code># from src/gui_manager.py\ndef start_stage_animation(self, estimated_duration, end_step):\n    self.animation_start_time = time.time()\n    self.animation_duration = estimated_duration\n    self.animation_start_value = self.stage_progress_bar.value()\n    # ... calculate animation_end_value based on end_step ...\n\n    self.animation_active = True\n    if not self.animation_timer.isActive():\n        self.animation_timer.start(50) # Start the animation timer (50ms interval)\n</code></pre></p> </li> <li> <p>Frame-by-Frame Update: A dedicated <code>QTimer</code> (<code>animation_timer</code>) calls the <code>update_animation</code> method every 50ms. This method calculates how much time has passed since the animation started, determines the corresponding progress percentage, and updates the progress bar's value. This creates the smooth visual effect.     <pre><code># from src/gui_manager.py\ndef update_animation(self):\n    if not self.animation_active:\n        return\n\n    elapsed = time.time() - self.animation_start_time\n\n    if self.animation_duration &gt; 0:\n        progress_ratio = min(elapsed / self.animation_duration, 1.0)\n    else:\n        progress_ratio = 1.0\n\n    value_range = self.animation_end_value - self.animation_start_value\n    current_value = self.animation_start_value + int(value_range * progress_ratio)\n\n    self.stage_progress_bar.setValue(current_value)\n</code></pre></p> </li> <li> <p>Termination: Once the actual task is complete in the study process, it sends an <code>end_animation</code> message. This stops the animation timer and sets the progress bar to its final, accurate value, correcting for any deviation between the estimate and the actual time taken.</p> </li> </ol> <p>Log Rotation:</p> <p>The <code>setup_loggers</code> function checks the number of log files in the <code>logs</code> directory. If it exceeds a limit (10 pairs), it deletes the oldest pair (<code>.log</code> and <code>.progress.log</code>) to prevent the directory from growing indefinitely.</p> <p>Handler Configuration: The function creates file handlers and stream (console) handlers for each logger, ensuring messages go to the right places. <code>propagate = False</code> is used to prevent messages from being handled by parent loggers, avoiding duplicate output.</p> <pre><code># from src/logging_manager.py\ndef setup_loggers(session_timestamp=None):\n    # ... log rotation logic ...\n\n    progress_logger = logging.getLogger('progress')\n    progress_logger.setLevel(logging.INFO)\n    # Remove existing handlers to prevent duplicates\n    for handler in progress_logger.handlers[:]:\n        progress_logger.removeHandler(handler)\n\n    # File handler for progress file\n    progress_file_handler = logging.FileHandler(progress_log_filename, mode='a')\n    progress_logger.addHandler(progress_file_handler)\n\n    # Stream handler for progress (console output)\n    progress_stream_handler = logging.StreamHandler()\n    progress_logger.addHandler(progress_stream_handler)\n    progress_logger.propagate = False\n\n    # ... similar setup for verbose_logger ...\n    return progress_logger, verbose_logger, session_timestamp\n</code></pre> <p>Configuration (<code>config.py</code>):</p> <p>The <code>Config</code> class uses a powerful inheritance mechanism to avoid duplicating settings.</p> <ul> <li> <p>Inheritance: A config can \"extend\" a base config. The <code>_load_config_with_inheritance</code> method recursively loads the base config and merges it with the child config. The child's values override the parent's.</p> <p><pre><code># from src/config.py\ndef _load_config_with_inheritance(self, path):\n    config = self._load_json(path)\n\n    if \"extends\" in config:\n        base_config_path = self._resolve_config_path(config[\"extends\"])\n        base_config = self._load_config_with_inheritance(base_config_path)\n\n        # Merge the base configuration into the current one\n        config = deep_merge(base_config, config)\n\n    return config\n</code></pre> For example, <code>near_field_config.json</code> might only specify the settings that differ from the main <code>base_config.json</code>.</p> </li> </ul> <p>Project Management:</p> <ul> <li><code>project_manager.py</code>: This class is critical for reliability. The underlying <code>.smash</code> project files can become corrupted or locked. The <code>_is_valid_smash_file</code> method is a key defensive measure. It first attempts to rename the file to itself (a trick to check for file locks on Windows) and then uses <code>h5py</code> to ensure the file is a valid HDF5 container before attempting to open it in the simulation software. This prevents the application from crashing on a corrupted file.</li> </ul> <p>This integrated system of GUI, logging, profiling, and configuration management provides a robust and user-friendly framework for running complex scientific simulations.</p>"},{"location":"developer_guide/#testing","title":"Testing","text":"<p>GOLIAT uses <code>pytest</code> for testing, with tests located in the <code>tests/</code> directory.</p>"},{"location":"developer_guide/#handling-the-s4l_v1-dependency","title":"Handling the <code>s4l_v1</code> Dependency","text":"<p>Much of the codebase requires <code>s4l_v1</code>, a proprietary library available only within the Sim4Life Python environment on Windows. This prevents tests that rely on it from running in the Linux-based CI environment.</p> <p>To manage this, tests requiring <code>s4l_v1</code> are marked with <code>@pytest.mark.skip_on_ci</code>. The CI pipeline is configured to exclude these marked tests, allowing it to validate platform-independent code while avoiding environment-specific failures.</p> <pre><code># Command used in .github/workflows/test.yml\npytest -m \"not skip_on_ci\" tests/\n</code></pre>"},{"location":"developer_guide/#local-testing-setup","title":"Local Testing Setup","text":"<p>To run the complete test suite, your local development environment must use the Sim4Life Python interpreter.</p>"},{"location":"developer_guide/#vs-code-configuration","title":"VS Code Configuration","text":"<ol> <li>Open the Command Palette (<code>Ctrl+Shift+P</code>).</li> <li>Run the <code>Python: Select Interpreter</code> command.</li> <li>Select <code>+ Enter interpreter path...</code> and find the <code>python.exe</code> in your Sim4Life installation directory (e.g., <code>C:\\Program Files\\Sim4Life\\8.2\\python\\python.exe</code>).</li> </ol> <p>This configures VS Code to use the correct interpreter, which includes the <code>s4l_v1</code> library.</p>"},{"location":"developer_guide/#running-tests-locally","title":"Running Tests Locally","text":"<p>With the interpreter set, run the full test suite from the terminal.</p> <ol> <li>Install Dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Run Pytest:     <pre><code># This executes all tests, including those skipped by CI\npytest tests/ -v\n</code></pre></li> </ol>"},{"location":"developer_guide/#adding-new-tests","title":"Adding New Tests","text":"<ul> <li>If a new test depends on <code>s4l_v1</code> (or imports a module that does), it must be decorated with <code>@pytest.mark.skip_on_ci</code>.</li> <li>If a test is self-contained and has no Sim4Life dependencies, it does not need the marker.</li> </ul> <pre><code>import pytest\nfrom src.utils import format_time # This module has s4l_v1 dependencies\n\n# This test requires the Sim4Life environment and will be skipped on CI.\n@pytest.mark.skip_on_ci\ndef test_a_function_that_needs_s4l():\n    # ... test logic ...\n    pass\n\n# This test is self-contained and will run everywhere.\ndef test_a_self_contained_function():\n    assert 2 + 2 == 4\n</code></pre>"},{"location":"developer_guide/#extending-the-framework","title":"Extending the Framework","text":""},{"location":"developer_guide/#adding-a-new-setup","title":"Adding a New Setup","text":"<p>To add a custom source (e.g., dipole):</p> <ol> <li>Create <code>src/setups/dipole_setup.py</code> inheriting BaseSetup.</li> <li>Implement <code>run_full_setup()</code>: Load dipole CAD, position.</li> <li>Update NearFieldStudy/FarFieldStudy to use it (e.g., if \"study_type\": \"dipole\").</li> <li>Add to config schema in config.py.</li> </ol> <p>Example in dipole_setup.py:</p> <pre><code>class DipoleSetup(BaseSetup):\n    def run_full_setup(self, project_manager):\n        # Custom logic\n        pass\n</code></pre>"},{"location":"developer_guide/#contribution-workflow","title":"Contribution Workflow","text":"<ol> <li>Fork the repo.</li> <li>Create branch: <code>git checkout -b feature/new-setup</code>.</li> <li>Code: Follow style (Black-formatted, type hints).</li> <li>Test locally: <code>pytest</code>.</li> <li>Commit: <code>git commit -m \"Add dipole setup\"</code>.</li> <li>PR to main: Describe changes, reference issues.</li> </ol> <p>PR requirements: - Lint with Black: <code>black src/</code>. - Tests: Add for new features. - Docs: Update user_guide.md if user-facing.</p>"},{"location":"developer_guide/#building-docs","title":"Building Docs","text":"<p>Use MkDocs:</p> <pre><code>mkdocs serve  # Local server at http://127.0.0.1:8000\n</code></pre> <p>Build: <code>mkdocs build</code> \u2013 outputs to site/.</p> <p>For UML (docs/classes.puml): Use PlantUML viewer or VS Code extension.</p>"},{"location":"developer_guide/#code-style","title":"Code Style","text":"<ul> <li>Formatter: Black (pip install black).</li> <li>Imports: isort.</li> <li>Linting: flake8.</li> <li>Types: Use typing (e.g., Dict[str, Any]).</li> <li>Docs: Google-style docstrings.</li> </ul> <p>Pre-commit hook (install: <code>pre-commit install</code>):</p> <pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n      - id: black\n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n</code></pre> <p>Run: <code>pre-commit run</code>.</p>"},{"location":"developer_guide/#other-notes","title":"Other Notes","text":"<ul> <li>Dependencies: requirements.txt (no Poetry).</li> <li>Gitignore: Ignore logs/, results/, .env.</li> <li>License: MIT \u2013 see LICENSE.</li> <li>Changelog: Update CHANGELOG.md for releases.</li> </ul> <p>For more, see Contributing.</p>"},{"location":"implementation_notes_cleanup/","title":"Auto-Cleanup Implementation Notes","text":""},{"location":"implementation_notes_cleanup/#how-previous-simulation-detection-works","title":"How \"Previous\" Simulation Detection Works","text":""},{"location":"implementation_notes_cleanup/#directory-based-isolation","title":"Directory-Based Isolation","text":"<p>Each simulation configuration (unique combination of phantom + frequency + placement) gets its own dedicated directory:</p> <pre><code>results/\n  near_field/\n    thelonious/\n      700MHz/\n        by_cheek_base_base/     \u2190 Simulation 1's directory\n          *.smash\n          *_Input.h5\n          *_Output.h5\n        by_cheek_base_up/       \u2190 Simulation 2's directory\n          *.smash\n          *_Input.h5\n          *_Output.h5\n      900MHz/\n        by_cheek_base_base/     \u2190 Simulation 3's directory\n          *.smash\n          *_Input.h5\n          *_Output.h5\n</code></pre>"},{"location":"implementation_notes_cleanup/#cleanup-logic","title":"Cleanup Logic","text":"<p>When <code>auto_cleanup_previous_results</code> is enabled:</p> <ol> <li>Before running simulation 1 again, the cleanup function looks in <code>results/near_field/thelonious/700MHz/by_cheek_base_base/</code></li> <li>It finds ALL files matching the configured patterns (<code>*_Output.h5</code>, <code>*_Input.h5</code>, <code>*.smash</code>)</li> <li>It deletes these files - they are from the \"previous\" run of this EXACT same configuration</li> </ol>"},{"location":"implementation_notes_cleanup/#key-points","title":"Key Points","text":"<p>\"Previous\" means: Files from the last run of this exact simulation configuration (same phantom, frequency, placement), not the chronologically previous simulation in a batch.</p> <p>Why this works safely: - Each unique simulation has its own isolated directory - When you re-run simulation 1, it only affects simulation 1's directory - Other simulations (2, 3, etc.) in different directories are unaffected</p> <p>Example workflow: <pre><code># First run (creates files)\nRun: thelonious/700MHz/by_cheek_base_base\n  \u2192 Creates: abc123_Output.h5, abc123_Input.h5, project.smash\n\n# Second run (with cleanup enabled)\nRun: thelonious/700MHz/by_cheek_base_base  (same configuration)\n  \u2192 BEFORE simulation: Deletes abc123_Output.h5, abc123_Input.h5, project.smash\n  \u2192 DURING simulation: Creates new xyz789_Output.h5, xyz789_Input.h5, etc.\n</code></pre></p>"},{"location":"implementation_notes_cleanup/#code-location","title":"Code Location","text":"<p>The cleanup happens in <code>src/simulation_runner.py</code>:</p> <pre><code>def run(self, simulation):\n    # Clean up previous output files if configured\n    if self.config.get_auto_cleanup_previous_results():\n        self._cleanup_previous_output_files()  # \u2190 Deletes files HERE\n\n    with self.study.subtask(\"run_simulation_total\"):\n        # ... rest of simulation ...\n</code></pre> <p>The project directory is determined by <code>src/project_manager.py</code>:</p> <pre><code>def create_or_open_project(self, phantom_name, frequency_mhz, placement_name):\n    # Creates path like: results/near_field/thelonious/700MHz/by_cheek/\n    project_dir = os.path.join(\n        self.base_results_dir,\n        phantom_name,\n        f\"{frequency_mhz}MHz\",\n        placement_name\n    )\n    self.project_path = os.path.join(project_dir, \"project.smash\")\n</code></pre>"},{"location":"implementation_notes_cleanup/#why-this-is-safe-for-serial-workflows","title":"Why This Is Safe for Serial Workflows","text":"<p>In a serial workflow where you run simulations one at a time: 1. Setup creates the project and files 2. Run executes the simulation and generates output 3. Extract pulls the results 4. When re-running the SAME simulation again, cleanup removes the old files 5. Each simulation configuration is in its own directory, so they don't interfere</p>"},{"location":"implementation_notes_cleanup/#why-this-is-dangerous-for-parallel-workflows","title":"Why This Is Dangerous for Parallel Workflows","text":"<p>In parallel execution: - Multiple processes might try to access the same directory simultaneously - One process could delete files while another is reading them - This is why the safety checks auto-disable cleanup when <code>batch_run: true</code></p>"},{"location":"implementation_notes_cleanup/#implementation-details","title":"Implementation Details","text":""},{"location":"implementation_notes_cleanup/#glob-patterns-used","title":"Glob Patterns Used","text":"<pre><code>file_patterns = {\n    \"output\": (\"*_Output.h5\", \"output\"),\n    \"input\": (\"*_Input.h5\", \"input\"),\n    \"smash\": (\"*.smash\", \"project\"),\n}\n</code></pre> <p>The <code>*</code> wildcard matches the hash prefix (e.g., <code>abc123_Output.h5</code>).</p>"},{"location":"implementation_notes_cleanup/#cleanup-timing","title":"Cleanup Timing","text":"<p>Cleanup happens: - When: At the end of <code>ResultsExtractor.extract()</code>, after all results have been saved. - Where: In the current project's directory and its <code>_Results</code> subdirectory. - What: All files matching the specified patterns for the current simulation.</p>"},{"location":"old_good_GUI-Profiling-Logger/","title":"Codebase Features: A Comprehensive Deep-Dive","text":"<p>This document details the architecture and workflow of the key operational features of the codebase, focusing on the graphical user interface (GUI), logging, session management, and the profiling/timing system.</p>"},{"location":"old_good_GUI-Profiling-Logger/#1-high-level-workflow","title":"1. High-Level Workflow","text":"<p>The application is designed to run scientific studies (e.g., Near-Field, Far-Field) which can be time-consuming. To provide user feedback and manage complexity, the system employs a multi-process architecture.</p> <ol> <li>Main Process: A lightweight PySide6 GUI (<code>ProgressGUI</code>) is launched. This GUI is responsible for displaying progress, logs, and timing information.</li> <li>Study Process: The actual study (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>) is executed in a separate process using Python's <code>multiprocessing</code> module. This prevents the GUI from freezing during intensive calculations.</li> <li>Communication: The study process communicates with the GUI process through a <code>multiprocessing.Queue</code>. It sends messages containing status updates, progress information, and timing data.</li> </ol> <p>The entry point for the study process is the <code>study_process_wrapper</code> function, which sets up a special <code>QueueGUI</code> object. This object mimics the real GUI's interface but directs all its output to the shared queue.</p> <pre><code># from src/gui_manager.py\ndef study_process_wrapper(queue, study_type, config_filename, verbose, session_timestamp, execution_control):\n    \"\"\"\n    This function runs in a separate process and executes the study.\n    It communicates with the main GUI process via a queue.\n    \"\"\"\n    # ... setup ...\n    class QueueGUI:\n        def __init__(self, queue):\n            self.queue = queue\n            self.profiler = None\n\n        def log(self, message, level='verbose'):\n            if level == 'progress':\n                self.queue.put({'type': 'status', 'message': message})\n\n        def update_overall_progress(self, current_step, total_steps):\n            self.queue.put({'type': 'overall_progress', 'current': current_step, 'total': total_steps})\n        # ... other methods ...\n\n    if study_type == 'near_field':\n        study = NearFieldStudy(config_filename=config_filename, verbose=verbose, gui=QueueGUI(queue))\n    # ...\n    study.run()\n    queue.put({'type': 'finished'})\n</code></pre> <pre><code>graph TD\n    A[Main Process: ProgressGUI] -- Spawns --&gt; B[Study Process: study_process_wrapper];\n    B -- Instantiates --&gt; Study[NearFieldStudy/FarFieldStudy];\n    Study -- Uses --&gt; QueueGUI[QueueGUI object];\n    QueueGUI -- Puts messages --&gt; C{multiprocessing.Queue};\n    C -- Polled by QTimer --&gt; A;\n    A -- Updates UI --&gt; D[User];\n</code></pre>"},{"location":"old_good_GUI-Profiling-Logger/#2-gui-gui_managerpy","title":"2. GUI (<code>gui_manager.py</code>)","text":"<p>The GUI provides a real-time view of the study's progress. It runs in the main process and is designed to be responsive, even while the heavy computation happens elsewhere.</p>"},{"location":"old_good_GUI-Profiling-Logger/#message-processing","title":"Message Processing","text":"<p>The <code>ProgressGUI</code> uses a <code>QTimer</code> that fires every 100ms, calling the <code>process_queue</code> method. This method drains the queue of any pending messages from the study process and updates the UI accordingly.</p> <pre><code># from src/gui_manager.py\nclass ProgressGUI(QWidget):\n    # ...\n    def process_queue(self):\n        while not self.queue.empty():\n            try:\n                msg = self.queue.get_nowait()\n                msg_type = msg.get('type')\n\n                if msg_type == 'status':\n                    self.update_status(msg['message'])\n                elif msg_type == 'overall_progress':\n                    self.update_overall_progress(msg['current'], msg['total'])\n                elif msg_type == 'stage_progress':\n                    self.update_stage_progress(msg['name'], msg['current'], msg['total'])\n                elif msg_type == 'start_animation':\n                    self.start_stage_animation(msg['estimate'], msg['end_value'])\n                # ... other message types ...\n            except Empty:\n                break\n</code></pre>"},{"location":"old_good_GUI-Profiling-Logger/#the-animation-system-a-closer-look","title":"The Animation System: A Closer Look","text":"<p>A key feature for user experience is the smooth animation of the stage progress bar. This is used for tasks where the simulation software doesn't provide real-time progress feedback, but we have a historical estimate of how long it should take.</p> <p>How it works:</p> <ol> <li> <p>Initiation: The study process, before starting a long-running subtask (like <code>run_simulation_total</code>), gets an estimated duration from the <code>Profiler</code>. It then sends a <code>start_animation</code> message to the GUI, containing this estimated duration.     <pre><code># from src/studies/far_field_study.py (conceptual)\ndef run_simulations(self):\n    # ...\n    if self.gui:\n        # Tell the GUI to start an animation for the next step\n        self.gui.start_stage_animation(\"run_simulation_total\", i + 1)\n    self.simulation_runner.run(sim)\n</code></pre>     The <code>QueueGUI</code> object in the study process gets the estimate from its profiler instance and puts the message on the queue.     <pre><code># from src/gui_manager.py\nclass QueueGUI:\n    # ...\n    def start_stage_animation(self, task_name, end_value):\n        estimate = self.profiler.get_subtask_estimate(task_name)\n        self.queue.put({'type': 'start_animation', 'estimate': estimate, 'end_value': end_value})\n</code></pre></p> </li> <li> <p>Animation Setup: When the <code>ProgressGUI</code> receives the <code>start_animation</code> message, it sets up the animation parameters. It records the <code>start_time</code>, the <code>duration</code> (from the profiler's estimate), the progress bar's <code>start_value</code>, and the <code>end_value</code> it needs to reach.     <pre><code># from src/gui_manager.py\ndef start_stage_animation(self, estimated_duration, end_step):\n    self.animation_start_time = time.time()\n    self.animation_duration = estimated_duration\n    self.animation_start_value = self.stage_progress_bar.value()\n    # ... calculate animation_end_value based on end_step ...\n\n    self.animation_active = True\n    if not self.animation_timer.isActive():\n        self.animation_timer.start(50) # Start the animation timer (50ms interval)\n</code></pre></p> </li> <li> <p>Frame-by-Frame Update: A dedicated <code>QTimer</code> (<code>animation_timer</code>) calls the <code>update_animation</code> method every 50ms. This method calculates how much time has passed since the animation started, determines the corresponding progress percentage, and updates the progress bar's value. This creates the smooth visual effect.     <pre><code># from src/gui_manager.py\ndef update_animation(self):\n    if not self.animation_active:\n        return\n\n    elapsed = time.time() - self.animation_start_time\n\n    if self.animation_duration &gt; 0:\n        progress_ratio = min(elapsed / self.animation_duration, 1.0)\n    else:\n        progress_ratio = 1.0\n\n    value_range = self.animation_end_value - self.animation_start_value\n    current_value = self.animation_start_value + int(value_range * progress_ratio)\n\n    self.stage_progress_bar.setValue(current_value)\n</code></pre></p> </li> <li> <p>Termination: Once the actual task is complete in the study process, it sends an <code>end_animation</code> message. This stops the animation timer and sets the progress bar to its final, accurate value, correcting for any deviation between the estimate and the actual time taken.</p> </li> </ol>"},{"location":"old_good_GUI-Profiling-Logger/#3-logging-logging_managerpy","title":"3. Logging (<code>logging_manager.py</code>)","text":"<p>The system uses Python's standard <code>logging</code> module, configured to provide two distinct streams of information.</p>"},{"location":"old_good_GUI-Profiling-Logger/#loggers","title":"Loggers:","text":"<ol> <li><code>progress</code> logger: For high-level, user-facing messages. These are shown in the GUI and saved to <code>*.progress.log</code>.</li> <li><code>verbose</code> logger: For detailed, internal messages. These are saved to the main <code>*.log</code> file.</li> </ol>"},{"location":"old_good_GUI-Profiling-Logger/#implementation-details","title":"Implementation Details:","text":"<ul> <li>Log Rotation: The <code>setup_loggers</code> function checks the number of log files in the <code>logs</code> directory. If it exceeds a limit (10 pairs), it deletes the oldest pair (<code>.log</code> and <code>.progress.log</code>) to prevent the directory from growing indefinitely.</li> <li>Handler Configuration: The function creates file handlers and stream (console) handlers for each logger, ensuring messages go to the right places. <code>propagate = False</code> is used to prevent messages from being handled by parent loggers, avoiding duplicate output.</li> </ul> <pre><code># from src/logging_manager.py\ndef setup_loggers(session_timestamp=None):\n    # ... log rotation logic ...\n\n    progress_logger = logging.getLogger('progress')\n    progress_logger.setLevel(logging.INFO)\n    # Remove existing handlers to prevent duplicates\n    for handler in progress_logger.handlers[:]:\n        progress_logger.removeHandler(handler)\n\n    # File handler for progress file\n    progress_file_handler = logging.FileHandler(progress_log_filename, mode='a')\n    progress_logger.addHandler(progress_file_handler)\n\n    # Stream handler for progress (console output)\n    progress_stream_handler = logging.StreamHandler()\n    progress_logger.addHandler(progress_stream_handler)\n    progress_logger.propagate = False\n\n    # ... similar setup for verbose_logger ...\n    return progress_logger, verbose_logger, session_timestamp\n</code></pre>"},{"location":"old_good_GUI-Profiling-Logger/#4-profiling-and-timing-utilspy-profiling_configjson","title":"4. Profiling and Timing (<code>utils.py</code>, <code>profiling_config.json</code>)","text":"<p>The <code>Profiler</code> class is the engine for the timing and progress estimation system.</p>"},{"location":"old_good_GUI-Profiling-Logger/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Phases and Weights: A study is divided into phases (<code>setup</code>, <code>run</code>, <code>extract</code>). <code>profiling_config.json</code> assigns a \"weight\" to each, representing its contribution to the total time.     <pre><code>// from configs/profiling_config.json\n{\n    \"phase_weights\": {\n        \"setup\": 0.299,\n        \"run\": 0.596,\n        \"extract\": 0.105\n    },\n    \"subtask_estimates\": {\n        \"setup_simulation\": 48.16,\n        \"run_simulation_total\": 107.54,\n        \"extract_sar_statistics\": 4.09\n    }\n}\n</code></pre></li> <li>Dynamic Weights: The profiler normalizes these weights based on which phases are active (controlled by <code>execution_control</code> in the config). If a user chooses to only run the <code>extract</code> phase, its weight becomes 1.0, and the progress for that phase represents 100% of the total work.</li> <li>Weighted Progress: The <code>get_weighted_progress</code> method provides a more accurate overall progress.     <pre><code># from src/utils.py\ndef get_weighted_progress(self, phase_name, phase_progress):\n    \"\"\"Calculates the overall progress based on phase weights.\"\"\"\n    total_progress = 0\n    for phase, weight in self.phase_weights.items():\n        if phase == phase_name:\n            total_progress += weight * phase_progress # Add partial progress of current phase\n        elif phase in self.completed_phases:\n            total_progress += weight # Add full weight of completed phases\n    return total_progress * 100\n</code></pre></li> <li>Time Estimation (ETA): The <code>get_time_remaining</code> method is adaptive. Initially, it relies on the <code>subtask_estimates</code>. Once one or more stages have completed, it switches to a more accurate method based on the actual average time taken per stage.</li> <li>Self-Improving Estimates: After a run, <code>save_estimates</code> calculates the average time for each timed subtask and writes these new averages back to <code>profiling_config.json</code>. This makes future estimates more accurate.</li> </ul>"},{"location":"old_good_GUI-Profiling-Logger/#5-configuration-configpy","title":"5. Configuration (<code>config.py</code>)","text":"<p>The <code>Config</code> class uses a powerful inheritance mechanism to avoid duplicating settings.</p> <ul> <li> <p>Inheritance: A config can \"extend\" a base config. The <code>_load_config_with_inheritance</code> method recursively loads the base config and merges it with the child config. The child's values override the parent's.</p> <p><pre><code># from src/config.py\ndef _load_config_with_inheritance(self, path):\n    config = self._load_json(path)\n\n    if \"extends\" in config:\n        base_config_path = self._resolve_config_path(config[\"extends\"])\n        base_config = self._load_config_with_inheritance(base_config_path)\n\n        # Merge the base configuration into the current one\n        config = deep_merge(base_config, config)\n\n    return config\n</code></pre> For example, <code>near_field_config.json</code> might only specify the settings that differ from the main <code>base_config.json</code>.</p> </li> </ul>"},{"location":"old_good_GUI-Profiling-Logger/#6-project-management","title":"6. Project Management","text":"<ul> <li><code>project_manager.py</code>: This class is critical for reliability. The underlying <code>.smash</code> project files can become corrupted or locked. The <code>_is_valid_smash_file</code> method is a key defensive measure. It first attempts to rename the file to itself (a trick to check for file locks on Windows) and then uses <code>h5py</code> to ensure the file is a valid HDF5 container before attempting to open it in the simulation software. This prevents the application from crashing on a corrupted file.</li> </ul> <p>This integrated system of GUI, logging, profiling, and configuration management provides a robust and user-friendly framework for running complex scientific simulations.</p>"},{"location":"project_info/","title":"Project Information","text":""},{"location":"project_info/#about-goliat","title":"About GOLIAT","text":"<p>GOLIAT (5G expOsure, causaL effects, and rIsk perception through citizen engAgemenT) is a research project that aims to characterize and monitor RF-EMF exposure, in particular 5G, provide novel insights into potential causal neuropsychological and biological effects, and understand risk perception and communication through citizen engagement using an integrative and transdisciplinary pan-European approach.</p> <p>The primary objectives of the project include:</p> <ul> <li>Automated Dosimetry: Creating a Python-based framework to automate simulations using the Sim4Life platform.</li> <li>Child Phantom Analysis: Performing simulations on detailed child phantoms, such as \"Thelonious\" and \"Eartha,\" to understand age-dependent effects.</li> <li>Comprehensive SAR Analysis: Calculating Specific Absorption Rate (SAR) metrics, including whole-body, head, trunk, and peak spatial-average SAR (psSAR10g) in sensitive tissues like the skin, eyes, and brain.</li> <li>Varied Exposure Scenarios: Investigating numerous exposure conditions, including different frequencies, antenna types, and device positions (e.g., by the cheek, in front of the eyes, near the belly).</li> </ul>"},{"location":"project_info/#funding-and-acknowledgements","title":"Funding and Acknowledgements","text":"<p>This work is part of the GOLIAT project, which has received funding from the European Union's Horizon Health program under the call HORIZON-HEALTH-2021-ENVHLTH-02-01 \u2013 Exposure to electromagnetic fields (EMF) and health.</p>"},{"location":"project_info/#project-partners","title":"Project Partners","text":"<p>The GOLIAT consortium consists of 22 partners from across Europe and the United States:</p> <ul> <li>Barcelona Institute for Global Health (ISGlobal), ES (Coordinator)</li> <li>Ghent University (UGent) and IMEC, BE (lead subtask 1.5)</li> <li>Telecom Paris (TP), FR</li> <li>Consiglio Nazionale delle Ricerche (CNR), IT</li> <li>Swiss Tropical and Public Health Institute (SwissTPH), CH</li> <li>Nofer Institute of Occupational Medicine (NIOM), PL</li> <li>University of Bristol (UNIVBRIS), UK</li> <li>Universit\u00e0 degli Studi di Torino (UNITO), IT</li> <li>Academisch Medisch Centrum (AMC), NL</li> <li>Centre National de la Recherche Scientifique (CNRS), FR</li> <li>National Institute of Industrial Environment and Risks (INERIS), FR</li> <li>University La Sapienza (UNIROMA1), IT</li> <li>University of Bologna (UNIBO), IT</li> <li>National Public Health Center (NPHC), HU</li> <li>University of P\u00e9cs (UP), HU</li> <li>University of Exeter Medical School (UNEXE), UK</li> <li>University of Vienna (UNIVIE), AT</li> <li>Science for Change (SfC), ES</li> <li>Norwegian University of Life Sciences (NMBU), NO</li> <li>Massachusetts General Hospital (MGH), US</li> <li>Harvard School of Public Health (HSPH), US</li> <li>University of Michigan (UMich), US</li> </ul>"},{"location":"quick_start/","title":"\ud83d\ude80 Quick Start: Your First GOLIAT Simulation","text":"<p>Welcome to GOLIAT! This guide will get you up and running with your first automated EMF dosimetry simulation in minutes. GOLIAT streamlines the entire process using Sim4Life, from scene setup to results analysis. We'll walk through a simple \"Hello World\" near-field simulation to calculate Specific Absorption Rate (SAR) in a digital human phantom.</p>"},{"location":"quick_start/#what-youll-achieve","title":"\ud83c\udfaf What You'll Achieve","text":"<p>By the end of this guide, you will have: - Cloned the GOLIAT repository. - Set up your Python environment with Sim4Life integration. - Configured a basic near-field simulation. - Run your first GOLIAT study. - Understood where to find and interpret the simulation results.</p>"},{"location":"quick_start/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before you begin, please ensure you have the following:</p> <ul> <li>Sim4Life: Version 8.2.2 or later, with a valid license. If you don't have it, you can download it from ZMT Zurich.</li> <li>Python: Version 3.11+ (GOLIAT is designed to use the Python distribution bundled with Sim4Life, so a separate Python installation is usually not required).</li> <li>Digital Phantom Models: GOLIAT will automatically download necessary phantom models (e.g., \"thelonious\" for a child, \"eartha\" for an adult) on its first run. You may be prompted to provide your email for licensing purposes.</li> <li>Antenna Models: Supported antenna models for various frequencies (e.g., a 700 MHz PIFA antenna) are also auto-downloaded as needed.</li> </ul> <p>\ud83d\udca1 Pro Tip: If you're new to EMF dosimetry or Sim4Life, it's helpful to familiarize yourself with core concepts like SAR (Specific Absorption Rate \u2013 the rate at which electromagnetic energy is absorbed by biological tissue) and digital human phantoms (realistic 3D models of the human body used for simulation).</p>"},{"location":"quick_start/#step-1-clone-the-repository-and-install-dependencies","title":"Step 1: Clone the Repository and Install Dependencies","text":"<p>First, open your terminal or command prompt and clone the GOLIAT repository:</p> <pre><code>git clone https://github.com/rwydaegh/goliat.git\ncd goliat\n</code></pre> <p>Next, install the required Python dependencies. It's crucial to use the Python environment provided by your Sim4Life installation.</p> <pre><code># 1. Source .bashrc to add Sim4Life Python to your PATH (one-time setup)\n#    Edit .bashrc in the project root if your Sim4Life path differs from the default.\nsource .bashrc\n\n# Example .bashrc content for Windows (adjust path as necessary):\n# export PATH=\"/c/Program Files/Sim4Life_8.2.2/Python:$PATH\"\n# export PYTHONPATH=\"/c/Program Files/Sim4Life_8.2.2/Python/Lib/site-packages:$PYTHONPATH\"\n\n# 2. Install Python packages\npip install -r requirements.txt\n</code></pre>"},{"location":"quick_start/#step-2-configure-your-first-study","title":"Step 2: Configure Your First Study","text":"<p>GOLIAT uses a flexible JSON-based configuration system located in the <code>configs/</code> directory. For your first simulation, we'll use a simple near-field configuration.</p> <ol> <li> <p>Choose a template:</p> <ul> <li>For Near-Field simulations (device close to the body), copy <code>configs/near_field_config.json</code> to <code>configs/my_first_near_field_study.json</code>.</li> <li>For Far-Field simulations (whole-body plane wave exposure), copy <code>configs/far_field_config.json</code> to <code>configs/my_first_far_field_study.json</code>.</li> </ul> </li> <li> <p>Edit your custom config (e.g., <code>configs/my_first_near_field_study.json</code>):     <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],  // We'll use the child phantom for this example\n  \"frequencies_mhz\": [700],    // A single frequency for a quick test run\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  }\n  // GOLIAT will default to a \"by_cheek\" placement for near-field if not specified\n}\n</code></pre> Note: GOLIAT's configuration system supports inheritance. Your custom config extends <code>base_config.json</code>, allowing you to override only the settings you need. For a deep dive into all available parameters, refer to the Configuration Guide.</p> </li> <li> <p>For oSPARC Cloud Runs (Optional): If you plan to use oSPARC for cloud-based simulations, create a <code>.env</code> file in your project root with your credentials:     <pre><code>OSPARC_API_KEY=your_osparc_api_key\nOSPARC_API_SECRET=your_osparc_api_secret\nOSPARC_API_SERVER=https://api.sim4life.science\nOSPARC_API_VERSION=v0\n</code></pre></p> </li> </ol>"},{"location":"quick_start/#step-3-run-your-first-simulation","title":"Step 3: Run Your First Simulation","text":"<p>Now you're ready to launch your first GOLIAT study! Execute the following command in your terminal:</p> <pre><code>python run_study.py --config configs/my_first_near_field_study.json\n</code></pre> <p>What to Expect: -   A GOLIAT GUI window will open, displaying real-time progress, status messages, and an estimated time of arrival (ETA). -   Behind the Scenes:     1.  GOLIAT will check for and download any required phantom and antenna models (this is a one-time process).     2.  It will then automatically build the simulation scene in Sim4Life, loading the specified phantom and placing the antenna (e.g., 8mm from the cheek).     3.  The simulation will run using the iSolve solver (locally) or be submitted to oSPARC (if configured for cloud batching).     4.  Finally, GOLIAT will extract key SAR metrics, including whole-body SAR, head/trunk SAR, and peak 10g SAR in various tissues (eyes, brain, skin). -   Duration: This initial test simulation typically takes 5-10 minutes, depending on your system and Sim4Life configuration.</p> <p>Visual Aid:  Placeholder for a screenshot of the GOLIAT GUI during a simulation run.</p>"},{"location":"quick_start/#step-4-view-and-analyze-results","title":"Step 4: View and Analyze Results","text":"<p>Once the simulation is complete, GOLIAT will save all results in a structured directory within the <code>results/</code> folder. For our example, you'll find outputs in <code>results/near_field/thelonious/700MHz/by_cheek/</code>.</p> <p>Key Output Files: -   <code>sar_results.json</code>: Contains normalized SAR values (e.g., mW/kg per 1W input power). -   <code>sar_stats_all_tissues.pkl</code>: A detailed Python pickle file with comprehensive tissue-specific data. -   Plots: Various plots, such as SAR heatmaps and bar charts, visualizing the results.</p> <p>You can also run the dedicated analysis script to aggregate and further process your results:</p> <p><pre><code>python run_analysis.py --config configs/my_first_near_field_study.json\n</code></pre> This will generate additional CSV files and plots in the <code>results/</code> directory.</p> <p>Example Results Plot:  Placeholder for an example plot generated by GOLIAT, showcasing SAR distribution.</p> <p>Troubleshooting: Encountering issues? Refer to the Troubleshooting Guide for common problems and solutions (e.g., Sim4Life licensing, Python path errors, disk space management).</p>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<p>Congratulations, you've successfully run your first GOLIAT simulation! Here's what you can do next:</p> <ul> <li>Customize Your Studies: Experiment with your configuration files to explore different frequencies, phantoms, and antenna placements.</li> <li>Manage Disk Space: If running multiple simulations serially, enable automatic cleanup to save space: <code>\"auto_cleanup_previous_results\": [\"output\"]</code>. See Configuration Guide.</li> <li>Scale with the Cloud: Learn how to leverage oSPARC for parallel, large-scale simulations by setting <code>\"batch_run\": true</code> in your config.</li> <li>Explore Tutorials: Dive deeper with our Basic Tutorial for more default runs, or the Advanced Tutorial for batching and complex scenarios.</li> </ul> <p>You're now simulating EMF exposure like a pro! If you have any questions or encounter further issues, please don't hesitate to open a GitHub Issue.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This section addresses common issues encountered when using GOLIAT. Issues are grouped by category, with steps to resolve them.</p>"},{"location":"troubleshooting/#sim4life-setup-issues","title":"Sim4Life Setup Issues","text":""},{"location":"troubleshooting/#sim4life-not-found-or-python-path-error","title":"Sim4Life Not Found or Python Path Error","text":"<ul> <li>Symptom: \"iSolve.exe not found\" or import errors for s4l_v1.</li> <li>Cause: Sim4Life Python not in PATH.</li> <li>Solution:</li> <li>Locate Sim4Life installation (default: C:\\Program Files\\Sim4Life_8.2.2).</li> <li>Edit <code>.bashrc</code> in project root with your path:      <pre><code>export PATH=\"/path/to/Sim4Life/Python:$PATH\"\nexport PYTHONPATH=\"/path/to/Sim4Life/Python/Lib/site-packages:$PYTHONPATH\"\n</code></pre></li> <li>Source: <code>source .bashrc</code>.</li> <li>Verify: <code>python -c \"import s4l_v1; print('OK')\"</code> \u2013 should print \"OK\".</li> </ul>"},{"location":"troubleshooting/#sim4life-license-or-phantom-download-fails","title":"Sim4Life License or Phantom Download Fails","text":"<ul> <li>Symptom: \"License error\" or phantom download prompt fails.</li> <li>Cause: Missing license or invalid email.</li> <li>Solution:</li> <li>Ensure Sim4Life is licensed (check via GUI).</li> <li>Update <code>download_email</code> in <code>configs/base_config.json</code> (e.g., \"your@email.com\").</li> <li>Rerun study \u2013 GOLIAT retries download.</li> <li>Manual alternative: Download phantoms from ZMT Zurich site, place in <code>data/</code>.</li> </ul>"},{"location":"troubleshooting/#project-and-file-issues","title":"Project and File Issues","text":""},{"location":"troubleshooting/#lock-files-prevent-access-smashs4l_lock","title":"Lock Files Prevent Access (.smash.s4l_lock)","text":"<ul> <li>Symptom: \"File locked\" or \"Project corruption\" error.</li> <li>Cause: Previous run crashed; lock file remains.</li> <li>Solution:</li> <li>Close all Sim4Life instances.</li> <li>Delete lock file: <code>rm results/.../.{project}.smash.s4l_lock</code>.</li> <li>Rerun. If persistent, restart machine.</li> </ul>"},{"location":"troubleshooting/#corrupted-project-file-smash","title":"Corrupted Project File (.smash)","text":"<ul> <li>Symptom: \"HDF5 format error\" or \"Could not open project\".</li> <li>Cause: Incomplete save or disk issue.</li> <li>Solution:</li> <li>Delete .smash file: <code>rm results/.../project.smash</code>.</li> <li>Set <code>\"do_setup\": true</code> in config to recreate.</li> <li>Check disk space/logs for hardware issues.</li> </ul>"},{"location":"troubleshooting/#execution-issues","title":"Execution Issues","text":""},{"location":"troubleshooting/#simulation-run-fails-isolveexe","title":"Simulation Run Fails (iSolve.exe)","text":"<ul> <li>Symptom: \"iSolve.exe failed with return code\" or no output.</li> <li>Cause: Path, kernel (Acceleware/CUDA), or input file issue.</li> <li>Solution:</li> <li>Verify iSolve path in code (src/simulation_runner.py).</li> <li>Try <code>\"kernel\": \"Software\"</code> in config for CPU fallback.</li> <li>Check <code>logs/*.log</code> for solver errors (e.g., grid too fine).</li> <li>Ensure <code>manual_isolve: true</code> in config.</li> </ul>"},{"location":"troubleshooting/#osparc-batch-submission-fails","title":"oSPARC Batch Submission Fails","text":"<ul> <li>Symptom: \"Invalid API key\" or \"Job failed\".</li> <li>Cause: .env missing/invalid or quota exceeded.</li> <li>Solution:</li> <li>Verify <code>.env</code> in root (OSPARC_API_KEY etc.; see User Guide).</li> <li>Test keys: Run a single cloud sim first.</li> <li>Check quotas in oSPARC dashboard (max ~61 jobs).</li> <li>For \"RETRYING\": Code auto-retries 3 times; check logs/osparc_submission_logs/.</li> <li>Cancel stuck jobs: <code>python scripts/cancel_all_jobs.py --config your_config.json</code>.</li> </ul>"},{"location":"troubleshooting/#no-results-extracted","title":"No Results Extracted","text":"<ul> <li>Symptom: Empty JSON/PKL or \"No SAR data\".</li> <li>Cause: <code>do_extract: false</code> or simulation failed.</li> <li>Solution:</li> <li>Set <code>\"do_extract\": true</code> in config.</li> <li>Verify simulation completed (check power_balance ~100%).</li> <li>Rerun extraction: <code>\"do_setup\": false, \"do_run\": false, \"do_extract\": true</code>.</li> </ul>"},{"location":"troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"troubleshooting/#config-loading-error","title":"Config Loading Error","text":"<ul> <li>Symptom: \"File not found\" or \"Unknown study_type\".</li> <li>Cause: Invalid path or missing <code>study_type</code>.</li> <li>Solution:</li> <li>Use full path: <code>--config configs/near_field_config.json</code>.</li> <li>Ensure <code>study_type</code>: \"near_field\" or \"far_field\".</li> <li>Validate JSON syntax.</li> </ul>"},{"location":"troubleshooting/#placement-or-antenna-not-found","title":"Placement or Antenna Not Found","text":"<ul> <li>Symptom: \"Could not find component\" or invalid placement.</li> <li>Cause: Custom config mismatch.</li> <li>Solution:</li> <li>Use default configs first.</li> <li>For custom, match <code>placement_scenarios</code> keys exactly.</li> <li>Antenna: Ensure freq in <code>antenna_config</code> keys.</li> </ul>"},{"location":"troubleshooting/#gui-and-logging-issues","title":"GUI and Logging Issues","text":""},{"location":"troubleshooting/#gui-freezes-or-no-progress","title":"GUI Freezes or No Progress","text":"<ul> <li>Symptom: Window unresponsive.</li> <li>Cause: Multiprocessing issue or long computation.</li> <li>Solution:</li> <li>Run headless: <code>python run_study_no_gui.py --config config.json</code>.</li> <li>Check <code>logs/*.progress.log</code> for updates.</li> <li>Reduce grid size for faster tests.</li> </ul>"},{"location":"troubleshooting/#logs-not-generating","title":"Logs Not Generating","text":"<ul> <li>Symptom: Empty <code>logs/</code> or no output.</li> <li>Cause: Permissions or rotation lock.</li> <li>Solution:</li> <li>Check permissions: <code>chmod -R 755 logs/</code>.</li> <li>Delete stale locks: <code>rm logs/log_rotation.lock</code>.</li> <li>Run with <code>--pid 1</code> for unique logs.</li> </ul>"},{"location":"troubleshooting/#disk-space-issues","title":"Disk Space Issues","text":""},{"location":"troubleshooting/#running-out-of-disk-space","title":"Running Out of Disk Space","text":"<ul> <li>Symptom: \"No space left on device\" or simulation failures.</li> <li>Cause: Large simulation output files accumulating.</li> <li>Solution:</li> <li>Enable automatic cleanup for serial workflows:      <pre><code>\"execution_control\": {\n  \"auto_cleanup_previous_results\": [\"output\"]\n}\n</code></pre></li> <li>Manually delete old <code>*_Output.h5</code>, <code>*_Input.h5</code> files from <code>results/</code> directories.</li> <li>Archive completed studies to external storage.</li> <li>See Configuration Guide for cleanup options.</li> </ul>"},{"location":"troubleshooting/#general-tips","title":"General Tips","text":"<ul> <li>Always check <code>logs/</code> and console for errors.</li> <li>Rerun phases individually using <code>execution_control</code>.</li> <li>For cloud: Monitor oSPARC dashboard for job details.</li> <li>For disk space: Use <code>auto_cleanup_previous_results</code> in serial workflows.</li> <li>Still stuck? Open GitHub Issue with log snippet.</li> </ul> <p>See User Guide for workflows.</p>"},{"location":"uml/","title":"UML Diagrams","text":"<p>These diagrams are generated from the Python sources under <code>src/</code> using Pyreverse (from Pylint). The generator script is <code>scripts/generate_uml.py</code>.</p> <ul> <li>Class diagram (PlantUML): classes.puml</li> <li>Packages diagram (PlantUML): packages_GOLIAT.puml</li> </ul> <p>How to view - Use any PlantUML viewer (e.g., VS Code PlantUML extension, IntelliJ PlantUML plugin, or https://www.plantuml.com/plantuml). - Alternatively, use a browser-based renderer such as Kroki (https://kroki.io) by uploading the .puml file.</p> <p>How to regenerate - Ensure the Sim4Life Python (with pip) is on PATH as described in the README. - Then run:   - Windows (with Sim4Life Python):      - \"D:\\Program Files\\Sim4Life_8.2.2.18061\\Python\\python.exe\" scripts/generate_uml.py   - Or from a shell session where <code>python</code> resolves to the Sim4Life Python:     - source .bashrc &amp;&amp; python scripts/generate_uml.py</p> <p>Notes - The generated PlantUML files are committed to docs/ so they can be downloaded and rendered externally without requiring additional MkDocs plugins. - If you want inline rendering inside MkDocs, add a PlantUML-capable Markdown extension or serve via Kroki. For example, the mkdocs-kroki plugin can render <code>@startuml ... @enduml</code> fences at build time.</p>"},{"location":"user_guide/","title":"\ud83d\udcd6 User Guide: Understanding GOLIAT Workflows","text":"<p>This guide provides a comprehensive, plain-language explanation of how GOLIAT operates, serving as your essential roadmap for running and analyzing EMF dosimetry simulations. We'll delve into the end-to-end workflows for both near-field (device close to the body, like a mobile phone) and far-field (whole-body exposure, such as environmental plane waves) scenarios.</p> <p>GOLIAT automates the intricate and often tedious aspects of EMF simulations: from downloading necessary models and constructing complex scenes in Sim4Life, to executing calculations and extracting critical metrics like Specific Absorption Rate (SAR).</p>"},{"location":"user_guide/#key-concepts-in-emf-dosimetry","title":"\ud83d\udca1 Key Concepts in EMF Dosimetry","text":"<p>Before diving into the workflows, let's clarify some fundamental terms:</p> <ul> <li>Phantoms: These are highly detailed digital human models (e.g., \"thelonious\" represents a 6-year-old boy, \"eartha\" an adult female). They serve as realistic 3D representations for safe and accurate simulation of EMF interaction with biological tissues.</li> <li>Near-Field Simulations: Focus on scenarios where an EMF source (e.g., an antenna in a mobile device) is in close proximity to the body. These simulations are crucial for assessing localized absorption, particularly in sensitive areas like the head, eyes, or limbs.</li> <li>Far-Field Simulations: Address scenarios involving plane waves impinging on the entire body from various directions (e.g., front, back, sides). These are typically used for evaluating environmental or broadcast exposure.</li> <li>Specific Absorption Rate (SAR): The primary output metric, representing the rate at which electromagnetic energy is absorbed per unit mass of biological tissue, typically expressed in milliwatts per kilogram (mW/kg) per 1W of input power. GOLIAT provides whole-body average SAR, localized SAR (e.g., head/trunk), and peak spatial-average SAR (psSAR) over 10g tissue cubes in specific organs (e.g., brain, eyes, skin).</li> <li>Configuration Files (Configs): JSON files that serve as the \"recipe\" for your simulations. They define all parameters, including phantom selection, frequencies, antenna properties, and execution controls. GOLIAT uses a hierarchical system where study-specific configs inherit from <code>base_config.json</code>, allowing for easy customization and overrides.</li> </ul>"},{"location":"user_guide/#end-to-end-workflow-from-config-to-analysis","title":"\ud83d\ude80 End-to-End Workflow: From Config to Analysis","text":"<p>GOLIAT's robust and modular design follows a clear, sequential flow: Load Config \u2192 Orchestrate Study \u2192 Setup Scene \u2192 Run Simulation \u2192 Extract Results \u2192 Analyze &amp; Plot.</p>"},{"location":"user_guide/#1-load-configuration","title":"1. Load Configuration","text":"<p>Your journey begins by specifying a configuration file. -   Execute your study using the command line:     <pre><code>python run_study.py --config configs/your_study_config.json\n</code></pre> -   GOLIAT intelligently merges your chosen configuration (e.g., <code>near_field_config.json</code>) with the <code>base_config.json</code>, applying overrides for specific parameters like solver settings or gridding refinements. -   A graphical user interface (GUI) will launch. Here, you can load your configuration (if not provided via CLI) and initiate the study by clicking \"Run Study\".</p> <p>\ud83d\udca1 Pro Tip: Configuration files are human-readable JSON. We recommend editing them in a code editor like VS Code. Start by copying one of the provided templates (e.g., <code>near_field_config.json</code>) and modify only the parameters relevant to your study, such as phantoms or frequencies. Refer to the Configuration Guide for a detailed breakdown of all parameters.</p>"},{"location":"user_guide/#2-orchestrate-study","title":"2. Orchestrate Study","text":"<p>The core logic of your simulation is managed by specialized Study classes (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>).</p> <ul> <li>Near-Field Example: If you're running a near-field study, the <code>NearFieldStudy</code> class will systematically loop through all defined phantoms, frequencies, and antenna placements. For instance, it might process \"thelonious\" phantom at 700 MHz with an antenna placed \"by_cheek\" (e.g., 8mm from the cheek).</li> <li>Far-Field Example: For far-field studies, the <code>FarFieldStudy</code> class iterates through phantoms, frequencies, incident directions (e.g., x_pos, y_neg), and polarizations (e.g., theta, phi) to ensure comprehensive coverage.</li> <li>Project Management: For each unique simulation scenario, GOLIAT creates a dedicated Sim4Life project file (<code>.smash</code>) within a structured <code>results/</code> directory (e.g., <code>results/near_field/thelonious/700MHz/by_cheek/</code>).</li> <li>Progress Tracking: The GUI provides real-time progress updates and an Estimated Time of Arrival (ETA), which becomes more accurate over time as GOLIAT learns from previous runs.</li> </ul>"},{"location":"user_guide/#3-setup-scene-in-sim4life","title":"3. Setup Scene in Sim4Life","text":"<p>This phase involves GOLIAT automatically constructing the 3D simulation environment within Sim4Life.</p> <ul> <li>Phantom Loading: The specified digital phantom model is downloaded (if not already present) and imported into the scene, complete with its detailed tissue segmentation (e.g., skin, brain, muscle).</li> <li>Antenna/Source Placement:<ul> <li>Near-Field: The CAD model of the antenna (e.g., PIFA or IFA type) is imported and precisely positioned relative to the phantom, according to the defined placement scenario (e.g., 8mm gap from the cheek, with a specific tilt).</li> <li>Far-Field: Instead of an antenna, a plane wave source is configured, specifying its electric field strength (e.g., 1 V/m), incident direction, and polarization.</li> </ul> </li> <li>Material Assignment: Appropriate electromagnetic properties (e.g., conductivity, permittivity) are assigned to all entities in the scene (tissues, antenna components) based on the specified frequency.</li> <li>Gridding: The simulation domain is discretized into a computational grid. GOLIAT intelligently applies gridding rules, using finer cells around critical areas like the antenna or phantom surface, and coarser cells elsewhere. This can be automatic or manually controlled via millimeter steps.</li> <li>Boundaries and Sensors: Perfectly Matched Layer (PML) boundaries are configured to absorb outgoing electromagnetic waves, preventing reflections. Point sensors are strategically placed (e.g., at the corners of the simulation bounding box) to monitor field values.</li> <li>Solver Configuration: The Finite-Difference Time-Domain (FDTD) solver is set up, typically leveraging GPU acceleration (e.g., Acceleware kernel) for faster computation.</li> </ul> <p>Visualizing the Scene: Imagine a detailed 3D model of a human phantom, with an antenna precisely positioned nearby, all enclosed within a computational grid. GOLIAT handles the complex process of voxelization, where the continuous 3D geometry is converted into discrete cells filled with specific tissue properties.</p>"},{"location":"user_guide/#4-run-simulation","title":"4. Run Simulation","text":"<p>With the scene meticulously set up, GOLIAT proceeds to execute the electromagnetic simulation.</p> <ul> <li>Local Execution: For local runs, GOLIAT directly invokes the Sim4Life iSolve.exe solver. The GUI remains responsive, displaying logs and progress updates as the solver runs.</li> <li>Cloud Execution (oSPARC): For large-scale or parallel studies, GOLIAT can generate the necessary input files (<code>.h5</code>) and submit them as jobs to the oSPARC cloud platform. It then monitors the status of these jobs (e.g., PENDING \u2192 RUNNING \u2192 SUCCESS).</li> <li>Duration: A single simulation can take anywhere from 5 to 30 minutes, depending on factors like grid resolution, frequency, and computational resources. All results are normalized to a 1W input power for consistency.</li> </ul> <p>Batch Mode: By setting <code>\"batch_run\": true</code> in your configuration, GOLIAT can manage multiple simulations concurrently, either locally (using <code>run_parallel_studies.py</code>) or on oSPARC. The GUI tracks the status of all jobs and automatically downloads results upon completion.</p>"},{"location":"user_guide/#5-extract-analyze-results","title":"5. Extract &amp; Analyze Results","text":"<p>After the simulation, GOLIAT's <code>ResultsExtractor</code> and <code>Analyzer</code> components take over to process and interpret the vast amount of raw data.</p> <ul> <li>SAR Extraction: The extractor pulls various SAR metrics from the simulation output:<ul> <li>Whole-Body SAR: The average SAR over the entire phantom.</li> <li>Localized SAR: Average SAR in specific regions, such as the head or trunk, relevant for localized exposures.</li> <li>psSAR10g: Peak spatial-average SAR over a 10-gram tissue cube, typically reported for sensitive organs like the eyes, brain, and skin.</li> <li>Power Balance: A crucial check to ensure energy conservation within the simulation, ideally close to 100%.</li> </ul> </li> <li>Normalization: All extracted SAR values are normalized to a 1W input power, providing a standardized basis for comparison.</li> <li>Output Files (located in the <code>results/</code> folder):<ul> <li><code>sar_results.json</code>: A JSON file containing the primary normalized SAR values.</li> <li><code>sar_stats_all_tissues.pkl</code>: A Python pickle file with detailed, tissue-specific SAR data.</li> <li>Plots: GOLIAT automatically generates a suite of visualizations, including SAR heatmaps (showing SAR distribution by tissue and frequency), bar charts (comparing SAR in different regions), and boxplots (illustrating SAR distributions).</li> </ul> </li> <li>Aggregated Analysis: You can run the dedicated analysis script (<code>python run_analysis.py --config your_config.json</code>) to aggregate results across multiple simulations and generate comprehensive CSV reports and additional plots.</li> </ul> <p>Example Output Interpretation: For a near-field 700MHz simulation with an antenna by the cheek, you might observe: -   Head SAR: 0.5 mW/kg (per 1W input). -   Brain psSAR10g: 2.1 mW/kg peak. For far-field studies, the analysis often involves aggregating results over different incident directions to determine worst-case exposure scenarios.</p>"},{"location":"user_guide/#near-field-vs-far-field-workflows-a-comparison","title":"\ud83d\udd04 Near-Field vs. Far-Field Workflows: A Comparison","text":"<p>While the core GOLIAT workflow remains consistent, the specifics of scene setup and analysis differ between near-field and far-field studies.</p>"},{"location":"user_guide/#near-field-workflow-device-exposure","title":"Near-Field Workflow (Device Exposure)","text":"<ul> <li>Primary Use Case: Assessing localized EMF exposure from devices held close to the body, such as mobile phones, wearables, or medical implants. The focus is on SAR in specific tissues and organs.</li> <li>Key Steps:<ol> <li>Configuration: Set <code>\"study_type\": \"near_field\"</code> and define specific <code>placement_scenarios</code> (e.g., \"by_cheek\", \"on_wrist\").</li> <li>Scene Setup: Involves importing a detailed CAD model of the device antenna and precisely positioning it relative to the phantom, often with a small air gap (e.g., 8mm).</li> <li>Simulation Run: Typically uses a harmonic excitation (single frequency) to simulate continuous wave exposure.</li> <li>Results Analysis: Concentrates on localized SAR values (e.g., head SAR, trunk SAR) and peak spatial-average SAR (psSAR10g) in sensitive tissues like the eyes, brain, and skin.</li> </ol> </li> <li>Free-Space Mode: GOLIAT supports a \"freespace\" phantom option, allowing you to run simulations of the antenna in isolation (without a body). This is useful for antenna characterization and validation.</li> </ul>"},{"location":"user_guide/#far-field-workflow-environmental-exposure","title":"Far-Field Workflow (Environmental Exposure)","text":"<ul> <li>Primary Use Case: Evaluating whole-body EMF exposure from distant sources, such as broadcast antennas, cellular base stations, or industrial equipment. The focus is on whole-body average SAR and overall field distribution.</li> <li>Key Steps:<ol> <li>Configuration: Set <code>\"study_type\": \"far_field\"</code> and define <code>incident_directions</code> (e.g., <code>[\"x_pos\", \"y_neg\"]</code>) and <code>polarizations</code> (e.g., <code>[\"theta\", \"phi\"]</code>).</li> <li>Scene Setup: Instead of a device, plane wave sources are configured to illuminate the phantom from multiple directions, covering a full range of exposure angles.</li> <li>Simulation Run: Multiple simulations are typically run for each frequency, covering all specified directions and polarizations (e.g., 12 simulations per frequency: 6 directions \u00d7 2 polarizations).</li> <li>Results Analysis: Focuses on whole-body average SAR and how SAR is distributed across the entire phantom, often aggregated over various exposure scenarios.</li> </ol> </li> <li>Auto-Induced Mode: While currently a placeholder, this mode is envisioned for future implementations to simulate EMF exposure induced by body motion or other dynamic scenarios.</li> </ul>"},{"location":"user_guide/#tips-for-success","title":"\u2705 Tips for Success","text":"<ul> <li>Scale Up Your Studies: For multi-core local execution, leverage <code>run_parallel_studies.py --num-splits 4</code> to distribute simulations across multiple CPU cores.</li> <li>Cloud Computing with oSPARC: For hundreds or thousands of simulations, oSPARC offers a cost-effective and fast cloud solution. Remember to set up your API keys in a <code>.env</code> file.</li> <li>Manage Disk Space: For serial workflows on machines with limited storage, use <code>\"auto_cleanup_previous_results\": [\"output\"]</code> to automatically delete previous simulation files. See Configuration Guide for details.</li> <li>Customize with Confidence: Feel free to modify frequencies and placements in your configuration files. However, for consistency with GOLIAT's protocols, it's generally recommended to keep the core antenna models fixed.</li> <li>Effective Debugging: Always consult the <code>logs/</code> directory for detailed error messages. You can also rerun specific phases of a study (e.g., <code>\"do_setup\": false, \"do_run\": false, \"do_extract\": true</code>) to isolate and debug issues more efficiently.</li> </ul> <p>You are now equipped to navigate GOLIAT and perform sophisticated EMF dosimetry simulations! For hands-on examples, proceed to the Tutorials. If you have any further questions or encounter issues, please open a GitHub Issue.</p> <p>Last updated: {date}</p>"},{"location":"tutorials/advanced/","title":"Advanced Tutorial: oSPARC Batching and Parallel Execution","text":"<p>This tutorial covers scaling simulations with oSPARC cloud batching and local parallel execution. oSPARC is useful for large studies (hundreds of simulations), while parallel uses multiple CPU cores locally.</p>"},{"location":"tutorials/advanced/#prerequisites","title":"Prerequisites","text":"<p>Complete Basic Tutorial. For oSPARC, add API keys to <code>.env</code> (see User Guide).</p>"},{"location":"tutorials/advanced/#osparc-batching","title":"oSPARC Batching","text":"<p>oSPARC allows parallel cloud runs. Workflow: Generate inputs locally \u2192 Submit batch \u2192 Download results \u2192 Extract.</p>"},{"location":"tutorials/advanced/#step-1-generate-input-files","title":"Step 1: Generate Input Files","text":"<p>Edit your config (e.g., <code>configs/my_advanced.json</code>):</p> <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"far_field\",\n  \"phantoms\": [\"thelonious\", \"eartha\"],\n  \"frequencies_mhz\": [700, 900],\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"only_write_input_file\": true,  // Generate .h5 files only\n    \"do_run\": false,\n    \"do_extract\": false,\n    \"batch_run\": false\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Outputs .h5 input files in <code>results/far_field/{phantom}/{freq}MHz/{project}.smash_Results/</code>.</li> </ul>"},{"location":"tutorials/advanced/#step-2-submit-batch-to-osparc","title":"Step 2: Submit Batch to oSPARC","text":"<p>Update config for submission:</p> <pre><code>{\n  \"execution_control\": {\n    \"batch_run\": true  // Enable batch submission\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>GUI monitors jobs (PENDING \u2192 SUCCESS).</li> <li>Handles submission, polling, downloads automatically.</li> <li>Logs in <code>logs/osparc_submission_logs/</code>.</li> </ul> <p>Notes: - Max ~61 parallel jobs (oSPARC limit). - Costs: Based on compute time; monitor in oSPARC dashboard. - Pitfalls: Ensure .env keys valid; check quotas. If job fails, retry with <code>\"do_run\": false, \"do_extract\": true</code>.</p>"},{"location":"tutorials/advanced/#step-3-extract-results","title":"Step 3: Extract Results","text":"<p>After jobs complete (GUI shows COMPLETED), update config:</p> <pre><code>{\n  \"execution_control\": {\n    \"do_setup\": false,\n    \"do_run\": false,\n    \"do_extract\": true,\n    \"batch_run\": false\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Processes downloaded results into JSON/CSV/plots.</li> </ul> <p>Expected: Aggregated SAR over phantoms/freqs, plots in <code>results/far_field/plots/</code>.</p>"},{"location":"tutorials/advanced/#local-parallel-execution","title":"Local Parallel Execution","text":"<p>For multi-core local runs, use <code>run_parallel_studies.py</code>. Splits config into subsets (e.g., phantoms or frequencies).</p>"},{"location":"tutorials/advanced/#step-1-prepare-config","title":"Step 1: Prepare Config","text":"<p>Use a large config (e.g., full near-field with multiple freqs/phantoms).</p>"},{"location":"tutorials/advanced/#step-2-split-and-run","title":"Step 2: Split and Run","text":"<p>Run:</p> <pre><code>python run_parallel_studies.py --config configs/near_field_config.json --num-splits 4\n</code></pre> <ul> <li>Splits: 4 configs in <code>configs/near_field_config_parallel/</code> (e.g., by phantoms).</li> <li>Launches 4 <code>run_study.py</code> processes (one GUI per process).</li> <li>Each handles subset; results merge in <code>results/</code>.</li> </ul> <p>Splitting Logic (from code): - 2 splits: Halve phantoms. - 4 splits: One per first 4 phantoms. - 8 splits: Split phantoms, then halve frequencies.</p> <p>Use <code>--skip-split</code> for existing split dir.</p> <p>Notes: Local parallel uses CPU cores; no cloud needed. For large studies, combine with batch for hybrid.</p>"},{"location":"tutorials/advanced/#comparing-results","title":"Comparing Results","text":"<p>After batch/parallel run, run analysis:</p> <pre><code>python run_analysis.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Aggregates all results.</li> <li>Plots: SAR distributions across scenarios.</li> </ul>"},{"location":"tutorials/advanced/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>oSPARC: \"Invalid API key\" \u2013 Check .env; regenerate keys.</li> <li>Parallel: \"Lock file\" \u2013 Delete stale <code>.lock</code> files in root.</li> <li>Memory: Reduce splits if RAM low.</li> </ul> <p>For more config details, see Configuration Guide.</p>"},{"location":"tutorials/basic/","title":"Basic Tutorial: Running a Default Study","text":"<p>This tutorial shows how to run a default near-field study using the provided configuration. It uses the \"thelonious\" phantom at 700 MHz with a cheek placement. The process includes loading the config, executing the simulation, and reviewing the results.</p>"},{"location":"tutorials/basic/#prerequisites","title":"Prerequisites","text":"<p>Follow the Quick Start to install dependencies and set up Sim4Life.</p>"},{"location":"tutorials/basic/#step-1-use-the-default-config","title":"Step 1: Use the Default Config","text":"<p>The default near-field configuration is <code>configs/near_field_config.json</code>. For this tutorial, we limit to one phantom and frequency for simplicity.</p> <p>Key settings in <code>near_field_config.json</code>: - <code>study_type</code>: \"near_field\" - <code>phantoms</code>: [\"thelonious\"] (6-year-old male phantom) - <code>frequencies_mhz</code>: [700] (single frequency; full config has more) - Placement: \"by_cheek\" (antenna 8 mm from cheek, default for this scenario)</p> <p>The config inherits from <code>base_config.json</code> for common settings like solver and gridding.</p>"},{"location":"tutorials/basic/#step-2-execute-the-study","title":"Step 2: Execute the Study","text":"<p>Run the study from the terminal:</p> <pre><code>python run_study.py --config configs/near_field_config.json\n</code></pre> <ul> <li>The GUI opens.</li> <li>Click \"Load Config\" and select <code>near_field_config.json</code> (or specify via CLI).</li> <li>Click \"Run Study\".</li> <li>The process:</li> <li>Downloads the phantom and antenna model if not present.</li> <li>Builds the simulation scene: Loads the phantom, positions the antenna.</li> <li>Configures materials and grid.</li> <li>Runs the simulation using the iSolve solver.</li> <li>Extracts results: SAR values and statistics.</li> </ul> <p>The GUI displays progress, estimated time, and logs. Check the console or <code>logs/</code> for detailed output.</p>"},{"location":"tutorials/basic/#step-3-examine-the-results","title":"Step 3: Examine the Results","text":"<p>Results are saved in <code>results/near_field/thelonious/700MHz/by_cheek/</code>:</p> <ul> <li><code>sar_results.json</code>: Summary metrics (e.g., \"head_SAR\": 0.45 mW/kg per 1W input).</li> <li><code>sar_stats_all_tissues.pkl</code>: Detailed SAR for all tissues (use pandas to load).</li> <li><code>sar_stats_all_tissues.html</code>: HTML table of tissue SAR values.</li> <li><code>point_sensor_data.png</code>: E-field magnitude plot at monitoring points (if enabled).</li> </ul> <p>Example from <code>sar_results.json</code>:</p> <pre><code>{\n  \"head_SAR\": 0.45,\n  \"peak_sar_10g_W_kg\": 2.1,\n  \"power_balance\": {\"Balance\": 99.87}\n}\n</code></pre> <p>SAR values are normalized to 1W input power.</p>"},{"location":"tutorials/basic/#step-4-run-the-analysis-script","title":"Step 4: Run the Analysis Script","text":"<p>To aggregate and visualize results:</p> <pre><code>python run_analysis.py --config configs/near_field_config.json\n</code></pre> <p>This generates: - <code>normalized_results_detailed.csv</code>: Per-simulation data. - <code>normalized_results_summary.csv</code>: Averages by frequency/scenario. - Plots in <code>results/near_field/plots/</code> (e.g., SAR by tissue).</p> <p>Load in Python for further analysis:</p> <pre><code>import pandas as pd\ndf = pd.read_csv(\"results/near_field/normalized_results_detailed.csv\")\nprint(df.describe())\n</code></pre>"},{"location":"tutorials/basic/#expected-results","title":"Expected Results","text":"<p>For thelonious/700MHz/cheek (approximate; varies by run):</p> <ul> <li>Head SAR: 0.4-0.5 mW/kg.</li> <li>Brain psSAR10g: 1.5-2.5 mW/kg.</li> <li>Whole-body SAR: ~0.2 mW/kg.</li> </ul> <p>These are normalized values. For far-field, see the far-field config.</p>"},{"location":"tutorials/basic/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\"Phantom download failed\": Ensure internet and email in <code>base_config.json</code>. Rerun to retry.</li> <li>Simulation slow: Reduce frequencies or use coarser grid in config.</li> <li>No output: Check <code>do_extract: true</code> in config; review logs for errors.</li> </ul>"},{"location":"tutorials/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Customize placements/frequencies: Intermediate Tutorial.</li> <li>Run far-field: Change config to <code>far_field_config.json</code>.</li> <li>Batch processing: Advanced Tutorial.</li> </ul> <p>This tutorial verifies the basic workflow. For more, see User Guide.</p> <p>Last updated: {date}</p>"},{"location":"tutorials/intermediate/","title":"\ud83e\uddd1\u200d\ud83d\udcbb Intermediate Tutorial: Customizing Placements and Frequencies","text":"<p>This tutorial builds upon the Basic Tutorial by demonstrating how to customize antenna placements and simulation frequencies in GOLIAT. You'll learn to modify configuration files to explore different exposure scenarios.</p>"},{"location":"tutorials/intermediate/#what-youll-achieve","title":"\ud83c\udfaf What You'll Achieve","text":"<p>By the end of this tutorial, you will be able to: -   Create a custom configuration file for intermediate studies. -   Define multiple frequencies for a single study. -   Specify custom antenna placements relative to the phantom. -   Run a study with your customized settings.</p>"},{"location":"tutorials/intermediate/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Ensure you have completed the Basic Tutorial and have a working GOLIAT environment.</p>"},{"location":"tutorials/intermediate/#step-1-create-a-custom-configuration-file","title":"Step 1: Create a Custom Configuration File","text":"<p>Instead of modifying the default <code>near_field_config.json</code>, we'll create a new configuration file to keep your changes organized.</p> <ol> <li> <p>Copy <code>configs/near_field_config.json</code> to <code>configs/my_intermediate_study.json</code>.     <pre><code>cp configs/near_field_config.json configs/my_intermediate_study.json\n</code></pre></p> </li> <li> <p>Open <code>configs/my_intermediate_study.json</code> in your code editor.</p> </li> </ol>"},{"location":"tutorials/intermediate/#step-2-define-multiple-frequencies","title":"Step 2: Define Multiple Frequencies","text":"<p>Let's add another frequency to our study. We'll simulate at both 700 MHz and 900 MHz.</p> <p>Locate the <code>\"frequencies_mhz\"</code> array and modify it:</p> <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700, 900], // Added 900 MHz\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  },\n  // ... rest of the config\n}\n</code></pre>"},{"location":"tutorials/intermediate/#step-3-specify-custom-antenna-placements","title":"Step 3: Specify Custom Antenna Placements","text":"<p>GOLIAT allows you to define various antenna placement scenarios. We'll add a new placement called \"by_ear\" and enable it for the \"thelonious\" phantom.</p> <ol> <li> <p>Add a <code>\"placement_scenarios\"</code> block to your <code>my_intermediate_study.json</code> (if it doesn't exist, or modify if it does). This block defines the base positions and orientations.</p> <p><pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700, 900],\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  },\n  \"placement_scenarios\": {\n    \"by_cheek\": {\n      \"positions\": {\"base\": [0, 0, 0]},\n      \"orientations\": {\"base\": [], \"up\": [{\"axis\": \"X\", \"angle_deg\": 10}]}\n    },\n    \"by_ear\": { // New placement scenario\n      \"positions\": {\"base\": [0, 50, 0]}, // Example: 50mm along Y-axis from origin\n      \"orientations\": {\"base\": [], \"rotate_z\": [{\"angle_deg\": 90}]} // Example: Rotate 90 deg around Z\n    }\n  },\n  // ... rest of the config\n}\n</code></pre> Note: The exact coordinates and rotations will depend on your antenna model and desired position. These are illustrative examples.</p> </li> <li> <p>Enable the new placement for the \"thelonious\" phantom in the <code>\"phantom_definitions\"</code> section:</p> <pre><code>{\n  // ...\n  \"phantom_definitions\": {\n    \"thelonious\": {\n      \"placements\": {\n        \"do_by_cheek\": true,\n        \"do_by_ear\": true // Enable the new placement\n      },\n      \"distance_from_cheek\": 8,\n      \"distance_from_ear\": 5 // Example: 5mm distance for \"by_ear\"\n    }\n  }\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/intermediate/#step-4-run-the-customized-study","title":"Step 4: Run the Customized Study","text":"<p>Save your <code>configs/my_intermediate_study.json</code> file. Now, execute the study using your new configuration:</p> <pre><code>python run_study.py --config configs/my_intermediate_study.json\n</code></pre> <p>GOLIAT will now run simulations for: -   \"thelonious\" phantom at 700 MHz with \"by_cheek\" placement. -   \"thelonious\" phantom at 700 MHz with \"by_ear\" placement. -   \"thelonious\" phantom at 900 MHz with \"by_cheek\" placement. -   \"thelonious\" phantom at 900 MHz with \"by_ear\" placement.</p> <p>You will see the GUI update as each simulation scenario is processed.</p>"},{"location":"tutorials/intermediate/#step-5-examine-the-results","title":"Step 5: Examine the Results","text":"<p>After the study completes, navigate to your <code>results/</code> directory. You will find new subdirectories corresponding to the additional frequency and placement:</p> <ul> <li><code>results/near_field/thelonious/700MHz/by_ear/</code></li> <li><code>results/near_field/thelonious/900MHz/by_cheek/</code></li> <li><code>results/near_field/thelonious/900MHz/by_ear/</code></li> </ul> <p>Each directory will contain its own <code>sar_results.json</code>, <code>sar_stats_all_tissues.pkl</code>, and plots.</p> <p>Run the analysis script to aggregate all results from this multi-scenario study:</p> <pre><code>python run_analysis.py --config configs/my_intermediate_study.json\n</code></pre> <p>This will generate aggregated CSVs and plots that include data from all frequencies and placements you defined.</p>"},{"location":"tutorials/intermediate/#troubleshooting","title":"\u26a0\ufe0f Troubleshooting","text":"<ul> <li>\"Placement not found\": Double-check that the placement name in <code>\"phantom_definitions\"</code> (e.g., <code>\"do_by_ear\": true</code>) exactly matches a key in your <code>\"placement_scenarios\"</code> block (e.g., <code>\"by_ear\"</code>).</li> <li>JSON Syntax Errors: Ensure your JSON file is correctly formatted. Use a JSON validator if you encounter issues.</li> <li>Simulation Time: Running multiple frequencies and placements will increase the total simulation time. Consider using fewer scenarios for quick tests.</li> </ul>"},{"location":"tutorials/intermediate/#next-steps","title":"\u27a1\ufe0f Next Steps","text":"<ul> <li>Advanced Batching: Learn how to run many simulations in parallel using oSPARC cloud batching in the Advanced Tutorial.</li> <li>Far-Field Studies: Explore environmental exposure scenarios by configuring a far-field study.</li> <li>Developer Guide: If you're interested in extending GOLIAT, refer to the Developer Guide.</li> </ul> <p>Last updated: {date}</p>"}]}